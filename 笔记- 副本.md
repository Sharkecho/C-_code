---

---

<p align="left">C语言</p>

[toc]

# Day 1（基础思路很简单，**细节是魔鬼**）

## 一、设置win10添加右键菜单 打开CMD命令行工具

HKEY_CLASSES_ROOT\Directory\Background\shell，
        ShowBasedOnVelocityId
        cmd.exe /s /k pushd "%V"
        E:\works\setting\icon.ico 

<img src="C:\Users\恒\AppData\Roaming\Typora\typora-user-images\image-20211115190023962.png" alt="image-20211115190023962" style="zoom:50%;" />

## 二、编译器、链接器

<img src="C:\Users\恒\AppData\Roaming\Typora\typora-user-images\image-20211116082638578.png" alt="image-20211116082638578" style="zoom:33%;" />

​       编译：把人方便阅读的代码翻译成机器代码，
​       链接：按照平台要求，组织数据、代码放在系统可以识别的要求位置。以及其
​                    它条件。
​       cl（可以跨平台） Link(各平台不同)

## 三、命令行执行C code

```
windows下,cl  /c仅编译不链接， 无/c就是编译链接都做完
​ cl + /c + 目标文件
```

## 四、include "" <> 区别

 	1、""查找文件目录外加环境变量
 	2、<>只找环境变量

## 五 、输入输出函数的各种用法

### 1、  printf()

```
          **函数原型**
​          include <stdio.h>
​          int printf(const char *format, ...);
​          返回值
​     	 **Return Value**
​          Each of these functions returns the number of characters printed, or a      negative value if an error occurs.

​            printf 的格式有四种：
​            1、printf("字符串\n");
​            2、printf("输出控制符"，输出参数);
​            3、printf("输出控制符1 输出控制符2…", 输出参数1, 输出参数2, …); 
​            4、printf("输出控制符 非输出控制符"，输出参数);   

<​          **函数原型**
​          include <stdio.h>
​          int printf(const char *format, ...);
​          返回值
​     	 **Return Value**
​          Each of these functions returns the number of characters printed, or a      negative value if an error occurs.

​            printf 的格式有四种：
​            1、printf("字符串\n");
​            2、printf("输出控制符"，输出参数);
​            3、printf("输出控制符1 输出控制符2…", 输出参数1, 输出参数2, …); 
​            4、printf("输出控制符 非输出控制符"，输出参数);   


```

<img src="C:\Users\恒\AppData\Roaming\Typora\typora-user-images\image-20211116074522597.png" alt="image-20211116074522597" style="zoom:50%;" /> 

getc,  getwc, getchar, getwchar

### <span style='background:yellow'>0、getc用法：</span>   

Each of these functions returns the character read. To indicate an read error  or end-of-file condition, **getc** and **getchar** return **EOF**, and  **getwc** and **getwchar** return **WEOF**. For **getc** and  **getchar**, use **ferror** or **feof** to check for an error or for  end of file
### <span style='background:yellow'>1、getchar用法：</span>   
getchar()C标准库提供的输入输出模型，都是按照字符流的方式处理
getchar()是最简单的一次读一个字符的函数，每次调用时从文本流中读入下一个字符，并将其作为结果值返回。
但是，注意的是，返回值是int型！即:

```text
int c;
c = getchar();
为什么不能是char型呢？ 
```

因为，在没有输入或者输入字符有错的时候，getchar()函数将返回一个特殊值，这个特殊值与任何实际字符都不同，称为EOF(end of file,文件结束)。EOF是定义在头文件

```c
#include <stdio.h>
main()
{
    int c;
    c = getchar();
    while(c != EOF)
    {
        putchar(c);
        c = getchar();
    }
}
```

是正确的！

当程序调用getchar()时，程序就等着用户按键。用户输入的字符被存放在键盘缓冲区中，直到用户按回车为止(回车字符也放在缓冲区中)。

当用户键入回车之后，getchar()才开始从输入流中每次读入一个字符，getchar()函数的返回值是用户输入的第一个字符的ASCII码,如出错返回EOF。如用户在按回车之前输入了不止一个字符，其他字符会保留在键盘缓存区中,，待后续getchar()调用读取。也就是说，后续的getchar()调用不会等待用户按键，而直接读取缓冲区中的字符，直到缓冲区中的字符读完为后，才等待用户按键。

getch与getchar的基本功能相同，不同就在于getch（所在头文件：conio.h）不等待回车，只要按下按键就会返回该键字符所对应的ASCII码。输入字符不回显。

Q:getchar()!=EOF的值？

Q:EOF的值？

```c
#include <stdio.h>
int main()
{
     int c;
     while(c = getchar() != EOF)
     {
        printf("%d\n",c);
     }
     printf("%d\n",c);
     printf("EOF = %d\n",EOF);
    return 0;
}
```

结果：

getchar()!=EOF的值为1；

EOF=-1;

```text
注： 
```

ctr-D:是一个特殊的二进制值，表示 EOF。

ct-Z:中断命令。

**从缓冲区读走一个字符，相当于清除缓冲区**

2.前面的scanf()在读取输入时会在缓冲区中留下一个字符'\n'（输入完s[i]的值后按回车键所致），所以如果不在此加一个getchar()把这个回车符取走的话，gets(）就不会等待从键盘键入字符，而是会直接取走这个“无用的”回车符，从而导致读取有误

3.getchar()是在输入缓冲区顺序读入一个字符(包括空格、回车和Tab)

getchar()使用不方便,解决方法：

（1）使用下面的语句清除回车：

```text
while(getchar()!='\n');   
```

（2**）用getche()或getch()代替getchar()，其作用是从键盘读入一个字符（不用按回车），注意要包含头文件<conio.h>**

## 七、代码规范

```http
windows:匈牙利    微软
linux:  —下划线是linux规范
int n,i;
float f,flt;
double d,dbl;
char c，
```
## 八、字符串指针

## 九、整数与字符串的相互转换

​               1、拓展函数 itoa
​		           itoa (表示 integer to alphanumeric)是把整型数转换成字符串的一个函数。
​                 windows 环境下，在 <stdlib.h> 头文件中有:
​                    

```http
char* itoa(int value,char*string,int radix);
//value: 要转换的整数，string: 转换后的字符串,radix: 转换进制数，如2,8,10,16 进制等。
```

```c
源码：
char* itoa(int num,char* str,int radix)
{
    char index[]="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";//索引表
    unsigned unum;//存放要转换的整数的绝对值,转换的整数可能是负数
    int i=0,j,k;//i用来指示设置字符串相应位，转换之后i其实就是字符串的长度；转换后顺序是逆序的，有正负的情况，k用来指示调整顺序的开始位置;j用来指示调整顺序时的交换。
 
    //获取要转换的整数的绝对值
    if(radix==10&&num<0)//要转换成十进制数并且是负数
    {
        unum=(unsigned)-num;//将num的绝对值赋给unum
        str[i++]='-';//在字符串最前面设置为'-'号，并且索引加1
    }
    else unum=(unsigned)num;//若是num为正，直接赋值给unum
 
    //转换部分，注意转换后是逆序的
    do
    {
        str[i++]=index[unum%(unsigned)radix];//取unum的最后一位，并设置为str对应位，指示索引加1
        unum/=radix;//unum去掉最后一位
 
    }while(unum);//直至unum为0退出循环
 
    str[i]='\0';//在字符串最后添加'\0'字符，c语言字符串以'\0'结束。
 
    //将顺序调整过来
    if(str[0]=='-') k=1;//如果是负数，符号不用调整，从符号后面开始调整
    else k=0;//不是负数，全部都要调整
 
    char temp;//临时变量，交换两个值时用到
    for(j=k;j<=(i-1)/2;j++)//头尾一一对称交换，i其实就是字符串的长度，索引最大值比长度少1
    {
        temp=str[j];//头部赋值给临时变量
        str[j]=str[i-1+k-j];//尾部赋值给头部
        str[i-1+k-j]=temp;//将临时变量的值(其实就是之前的头部值)赋给尾部
    }
 
    return str;//返回转换后的字符串
 
}
```

```c
实例：
#include <stdlib.h>
#include <stdio.h>
int main()
{
    int number1 = 123456;
    int number2 = -123456;
    char string[16] = {0};
    itoa(number1,string,10);
    printf("数字：%d 转换后的字符串为：%s\n",number1,string);
    itoa(number2,string,10);
    printf("数字：%d 转换后的字符串为：%s\n",number2,string);
    return 0;
}

```

​		





## 附录（作业）

# Day 2

##  一、窗口暂停使用：

```http
跨平台：gechar();
win（dos专用)：system();        #include <stdlib.h>
```

## 二、计算机内存管理方式与如何查看内存数据

​          小尾存储：PC 移动设备  低地址存低数据位，高地址存高数据位。主流
​          大端存储：大型机
​          内存管理：最小管理单位（4字节）
​                               以 字节为单位，搜索太慢，所以每个变量的首地址都是4的倍数
​			![image-20211117090740813](C:\Users\恒\AppData\Roaming\Typora\typora-user-images\image-20211117090740813.png)

自动编译bat脚本：

```
的
```



## 三、计算机如何通过位运算处理四则运算？

​           1、&、
  	     2、|
​           3、^
​           4、~

​       <span style=" background:yellow;">**计算机用移位和加法表示乘法**</span>
$$
A*18 = A * (1000 + 10)
\\
                         10000A + 10A
                         \\
                          A<<4+A<<2
                          \\
            n进制分解成 n^n  次幂累加；
$$

​	     <span style=" background:yellow;">**计算机除法原型**</span>    
$$
\frac{A}{C}=A*\frac{1}{C}=A*\frac{2^N}{C}*\frac{1}{2^N}
\\
M=\frac{2^N}{C}
\\
AM >>N
$$
​          <span style=" background:yellow;">**计算机减法实现原理**</span>  
​                               
$$
A-B(假定单字节)
\\
A + (100h-B)-100h
\\
B+ `B =FF
\\
B+`B+1=100h
\\
   `B+1=100h-B
   \\
A+`B+1-100h = A-B
\\
A+neg(B)-100h
$$

  ## 四、负数的存储

​	 补码：是编码（用来表达有符号数），双方协定的协议，反码+1
​            求补：法则，对值进行取反+1；
​	         最高有效位，记录符号，其余位记录数据

```txt
一. 机器数和真值
在学习原码, 反码和补码之前, 需要先了解机器数和真值的概念.

1、机器数
一个数在计算机中的二进制表示形式,  叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1.

比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。

那么，这里的 00000011 和 10000011 就是机器数。

2、真值
因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。

例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1

 

二. 原码, 反码, 补码的基础概念和计算方法.
在探求为何机器要使用补码之前, 让我们先了解原码, 反码和补码的概念.对于一个数, 计算机要使用一定的编码方式进行存储. 原码, 反码, 补码是机器存储一个具体数字的编码方式.

1. 原码
原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:

[+1]原 = 0000 0001

[-1]原 = 1000 0001

第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:

[1111 1111 , 0111 1111]

即

[-127 , 127]

原码是人脑最容易理解和计算的表示方式.

2. 反码
反码的表示方法是:

正数的反码是其本身

负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.

[+1] = [00000001]原 = [00000001]反

[-1] = [10000001]原 = [11111110]反

可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.

3. 补码
补码的表示方法是:

正数的补码就是其本身

负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)

[+1] = [00000001]原 = [00000001]反 = [00000001]补

[-1] = [10000001]原 = [11111110]反 = [11111111]补

对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.

 三. 为何要使用原码, 反码和补码
在开始深入学习前, 我的学习建议是先"死记硬背"上面的原码, 反码和补码的表示方式以及计算方法.

现在我们知道了计算机可以有三种编码方式表示一个数. 对于正数因为三种编码方式的结果都相同:

[+1] = [00000001]原 = [00000001]反 = [00000001]补

所以不需要过多解释. 但是对于负数:

[-1] = [10000001]原 = [11111110]反 = [11111111]补

可见原码, 反码和补码是完全不同的. 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢?

首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别"符号位"显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.

于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码:

计算十进制的表达式: 1-1=0

1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2

如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数.

为了解决原码做减法的问题, 出现了反码:

计算十进制的表达式: 1-1=0

1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0

发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在"0"这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0.

于是补码的出现, 解决了0的符号以及两个编码的问题:

1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原

这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128:

(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补

-1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]补 就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的)

使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127].

因为机器使用补码, 所以对于编程中常用到的32位int类型, 可以表示范围是: [-231, 231-1] 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值.

 四 原码, 反码, 补码 再深入
计算机巧妙地把符号位参与运算, 并且将减法变成了加法, 背后蕴含了怎样的数学原理呢?

将钟表想象成是一个1位的12进制数. 如果当前时间是6点, 我希望将时间设置成4点, 需要怎么做呢?我们可以:

1. 往回拨2个小时: 6 - 2 = 4

2. 往前拨10个小时: (6 + 10) mod 12 = 4

3. 往前拨10+12=22个小时: (6+22) mod 12 =4

2,3方法中的mod是指取模操作, 16 mod 12 =4 即用16除以12后的余数是4.

所以钟表往回拨(减法)的结果可以用往前拨(加法)替代!

现在的焦点就落在了如何用一个正数, 来替代一个负数. 上面的例子我们能感觉出来一些端倪, 发现一些规律. 但是数学是严谨的. 不能靠感觉.

首先介绍一个数学中相关的概念: 同余

 

同余的概念
两个整数a，b，若它们除以整数m所得的余数相等，则称a，b对于模m同余

记作 a ≡ b (mod m)

读作 a 与 b 关于模 m 同余。

举例说明:

4 mod 12 = 4

16 mod 12 = 4

28 mod 12 = 4

所以4, 16, 28关于模 12 同余.

负数取模
正数进行mod运算是很简单的. 但是负数呢?

下面是关于mod运算的数学定义:

clip_image001

上面是截图, "取下界"符号找不到如何输入(word中粘贴过来后乱码). 下面是使用"L"和"J"替换上图的"取下界"符号:

x mod y = x - y L x / y J

上面公式的意思是:

x mod y等于 x 减去 y 乘上 x与y的商的下界.

以 -3 mod 2 举例:

-3 mod 2

= -3 - 2xL -3/2 J

= -3 - 2xL-1.5J

= -3 - 2x(-2)

= -3 + 4 = 1

所以:

(-2) mod 12 = 12-2=10

(-4) mod 12 = 12-4 = 8

(-5) mod 12 = 12 - 5 = 7

 
开始证明
再回到时钟的问题上:

回拨2小时 = 前拨10小时

回拨4小时 = 前拨8小时

回拨5小时= 前拨7小时

注意, 这里发现的规律!

结合上面学到的同余的概念.实际上:

(-2) mod 12 = 10

10 mod 12 = 10

-2与10是同余的.

(-4) mod 12 = 8

8 mod 12 = 8

-4与8是同余的.

距离成功越来越近了. 要实现用正数替代负数, 只需要运用同余数的两个定理:

反身性:

a ≡ a (mod m)

这个定理是很显而易见的.

线性运算定理:

如果a ≡ b (mod m)，c ≡ d (mod m) 那么:

(1)a ± c ≡ b ± d (mod m)

(2)a * c ≡ b * d (mod m)

如果想看这个定理的证明, 请看:http://baike.baidu.com/view/79282.htm

所以:

7 ≡ 7 (mod 12)

(-2) ≡ 10 (mod 12)

7 -2 ≡ 7 + 10 (mod 12)

现在我们为一个负数, 找到了它的正数同余数. 但是并不是7-2 = 7+10, 而是 7 -2 ≡ 7 + 10 (mod 12) , 即计算结果的余数相等.

接下来回到二进制的问题上, 看一下: 2-1=1的问题.

2-1=2+(-1) = [0000 0010]原 + [1000 0001]原= [0000 0010]反 + [1111 1110]反

先到这一步, -1的反码表示是1111 1110. 如果这里将[1111 1110]认为是原码, 则[1111 1110]原 = -126, 这里将符号位除去, 即认为是126.

发现有如下规律:

(-1) mod 127 = 126

126 mod 127 = 126

即:

(-1) ≡ 126 (mod 127)

2-1 ≡ 2+126 (mod 127)

2-1 与 2+126的余数结果是相同的! 而这个余数, 正式我们的期望的计算结果: 2-1=1

所以说一个数的反码, 实际上是这个数对于一个膜的同余数. 而这个膜并不是我们的二进制, 而是所能表示的最大值! 这就和钟表一样, 转了一圈后总能找到在可表示范围内的一个正确的数值!

而2+126很显然相当于钟表转过了一轮, 而因为符号位是参与计算的, 正好和溢出的最高位形成正确的运算结果.

既然反码可以将减法变成加法, 那么现在计算机使用的补码呢? 为什么在反码的基础上加1, 还能得到正确的结果?

2-1=2+(-1) = [0000 0010]原 + [1000 0001]原 = [0000 0010]补 + [1111 1111]补

如果把[1111 1111]当成原码, 去除符号位, 则:

[0111 1111]原 = 127

其实, 在反码的基础上+1, 只是相当于增加了膜的值:

(-1) mod 128 = 127

127 mod 128 = 127

2-1 ≡ 2+127 (mod 128)

此时, 表盘相当于每128个刻度转一轮. 所以用补码表示的运算结果最小值和最大值应该是[-128, 128].

但是由于0的特殊情况, 没有办法表示128, 所以补码的取值范围是[-128, 127]
```



## 五、putc与putchar区别

​    putc（int ch，FILE *fp），即将字符ch输出到fp所指的文件中；
​             putchar（char ch)，即将字符ch输出到标准输出设备上。

​    1、 putc是函数， putchar()是在stdio.h里定义的宏；
​            2、 putc是文件操作函数， 而putchar()则是设备操作

六、puts, _putws

## 六、**常量INT_MAX和INT_MIN分别表示最大、最小整数，定义在头文件limits.h中**

## 七、取模的理解&取模运算涉及的算法

> ```
> 取模运算
> 背景
> 取模运算(mod)和取余运算(rem)两个概念有重叠的部分，但又不完全一致；主要区别在于对负整数进行除法运算时操作不同。取模主要是用于计算机术语中；取余则更多是数学概念。
> 
> 取模和取余的区别
> 取余运算 在计算商值时 商值向0方向舍入；靠近0原则
> 取模运算 在计算商值时 商值向负无穷方向舍入；尽可能让商值小的原则(不超多商值的最大值)
> 计算步骤
> 假设有整数a和b，那么取模/取余运算可以分为两步运算：
> 
> 求整数商：c = a/b;
> 计算模/余数：r = a - (c*b);
> 总计算模/余数：a mod b = a - b[a/b] ([a/b]表示整数商)
> 例子
> 取模
> 
> 简述	商值		取模值
> 5 mod 3 = 2	5/3 = 1.66 商取小原则 商=1	5 - 3 * 1 = 2	2
> -5 mod 3 = 1	-5/3 = -1.66 商取小原则 商=-2	-5 - (3 * -2) = 1	1
> 5 mod -3 = -1	5/-3 = -1.66 商取小原则 商=-2	5 - (-3 * -2) = -1	-1
> -5 mod -3 = -2	-5/-3 = 1.66 商取小原则 商=1	-5 - (-3 * 1) = 2	-2
> 取余
> 
> 简述	商值		取余值
> 5 rem 3 = 2	5/3 = 1.66 商靠0原则 商=1	5 - 3 * 1 = 2	2
> -5 rem 3 = -2	-5/3 = -1.66 商靠0原则 商=-1	-5 - (3 * -1) = - 2	-2
> 5 rem -3 = 2	5/-3 = -1.66 商靠0原则 商=-1	5 - (-3 * -1) = 2	2
> -5 rem -3 = -2	-5/-3 = 1.66 商靠0原则 商=1	-5 - (-3 * 1) = - 2	-2
> java 中 % 是取余运算；Python中 % 是取模运算
> 
> 模的理解
> “模”是指一个计量系统的计数范围；如时钟，12个整点为计算范围，则模为12；计算机也是一个计量机器，模为32位或者64位；
> 
> 32位计算机正常理解 在模 范围内能表达的 有 [0, 2³²-1]；那么负数该怎么表达呢，所以出现了补码；也就是 正数 + 负数 正好达到模的溢出阀值2³²；所以在计算机中负数是用补码方式表达的原因；
> 
> 关于补码的例子：在12模的时钟中；假设当前时针指向10点,而准确时间是6点,调整时间可有以下两种拨法
> 
> 倒拨4小时,即：10-4=6 (10-4) mod 12 = 6
> 顺拨8小时：10+8=12+6=6 （10+8）mod 12 = 6
> 在以12模的系统中，加8和减4效果是一样的；因此凡是减4运算，都可以用加8来代替。对“模”而言，8和4互为补数。实际上以12模的系统中11和1、10和2、9和3、7和5、6和6都有这个特性；共同的特点是两者相加等于模
> 
> “取模”实质上是计量器产生“溢出”的量，它的值在计量器上表示不出来，计量器上只能表示出模的余数(取模)；任何有模的计量器，均可化为加减法运算
> 
> 5 mod 3 = 2 例子中；模 为 3；2 为取模的值
> 
> 计算机中取模应用思想
> 取模的本质是：取模的值，必定会模的范围内；所以，计算机领域引用该特性，使元素路由算法不超出边界，并有规则存放。
> 
> 首先确定模(范围)；元素取模，使元素有规则的落入模的范围内容器中
> 
> 如：hashMap、数据库分表、分布式节点路由算法等
> 
> 作者：蜗牛写java
> 链接：https://www.jianshu.com/p/5e1a83e8be3b
> 来源：简书
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
> ```


https://github.com/wujr5/algorithm-analysis-and-design/blob/master/relative-algorithm-learning/6-algorithm-about-modulo-operation.md


## 附录：作业

  1、使用printf() 函数显示下列菜单： 
        menu

1. Input the students’ names and scores 

2. Search scores of some students

3. Modify scores of some students

4. List all students’ scores 

5. ###### Quit the system 

​    Please input your choise (1-5): 

2.	参照例1.7和例1.8，选择一种方法编写一个程序，实现输入 
      	六个数输出最小数。 
   
3.	编写一个程序，从键盘上输入华氏温度，屏幕显示对应的
	摄氏温度。华氏温度和摄氏温度的转换公式为： 
	c=(f-32)/1.8 
	
4.  编程输出字符0、9、A、Z、a、z的ACSII码的十进制、八进制和十六进制的表示形式。 

5.  参考例L2_6.C编写一个程序，从键盘输入字符（例如’1’），转换成十进制数（即1），并输出。
    提示：“1”的ASCII码为十进制数49，将其减去一个数等于十进制1即可。 

6.  已知a=3，b=2，c=2.5，计算(float)(a+b)/3+(int)c的值。 

7.  编写一个程序输出5！、10！的结果。 

8.  参考例L2_8.C编写一个程序，输入2个学生的姓名、学号、英语、数学、计算机成绩，输出这两个学生的姓名、学号和平均分。

    ---

    1.	写出58.25的16进制
    2.	自己写程序查看float定义数据的内存。
    3.	将asscii码表打出来，并观察对应关系
    4.	写程序将36由int转为char,和double并查看其内存值
    5.	输入矩形的两个边的值(浮点型)，求其面积
    6.	写程序说明一下int和long在内存中的区别，（即数据大小）
    7.	编程说明long double、long int和double long它们在内存中的区别

# Day 3



##  一、隐士转换问题

当表达式运算时，数据类型不匹配，会发生自动隐士转换；
​         隐士转换的本质还是数据的存储问题。
​            

排序 查找

 线性排序

scanf:作用

C 05 内存访问错误 



## 二、大数存储问题

https://www.codeleading.com/article/59656111373/

https://www.codeleading.com/article/54425639384/

所谓大数计算，差不多就是模拟你手算的过程的程序实现。

记录数据用字符串，解决办法之一就是：以个位作为参考点，像小学时代那样一位一位算即可

![img](https://img-blog.csdnimg.cn/20200413161639181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R1anVhbmNhbzEx,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20200413161933264.png)

![img](https://img-blog.csdnimg.cn/2020041316242571.png)



##### 1、字符串转整数

```c
这个字符串参数必须包含一个或多个数字，函数应该把这些数字字符转换为整数并返回这个整数。如果字符串参数包含了任何非数字字符，函数就返回零。请不必担心算术溢出。
提示：这个技巧很简单你每发现一个数字，把当前值乘以10，并把这个值和新数字所代表的值相加。
这个问题应该用迭代方法解决，而不应采用递归方法。
#include <stdio.h>
// 把一个数字字符串转换为一个整数。
int ascii_to_integer( char *string )
{
    int value; value = 0;
    // 逐个把字符串的字符转换为数字。
    while( *string >= '0' && *string <= '9' ){
        value *= 10;
        value += *string - '0';
        string++;
    }
    //错误检查：如杲由于遇到一个非数字字符而终止，把结果设置为0
    if( *string != '\0' )
        value = 0;
    return value;
}
int main()
{
    char* numChar = "102";
    printf("%d\n", ascii_to_integer(numChar)+3);
    
    return 0;
}
```



## 三、浮点数的存储问题

## 四、内存对齐

操作系统 上下分	2G   80包含80属于操作系统

## 附录：作业

```
1、100!的阶乘。存储
```



# Day4（分支与循环）

##  一、 VC6-Ide基本设置与使用

​     a)、Tool选项卡：
​                    <img src="http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211118165530877.png" alt="image-20211118165530877" style="zoom: 67%;" />
​				b)、formart选项卡：字体设置\常量颜色设置
​	                <img src="http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211118170349787.png" alt="image-20211118170349787" style="zoom:33%;" /><img src="http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211118170532826.png" alt="image-20211118170532826" style="zoom:33%;" />

​     c)、工程选项卡：
​			          <img src="http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211118171522033.png" alt="image-20211118171522033" style="zoom: 50%;" />   

​            配置文件信息都保存在工程目录下的 dsp文件 ，如果有需求修改编译选项 可自行修改       script。  
​            d)使用：
​							f7  编译+链接
​						   CTR+F7  仅编译不链接
​							 f9  设置断点
​                       f5  调试环境运行（配置F9使用）
​                       CTR+F5	脱离调试直接运行
​                              dst；里包含编译选项

​                       dsw:每个项目是一个单独一个项目，多个项目组成一个工作空间
​							  f10 单步调试（查看结果）
​            				f11 单步(查看过程)
 						SHIT+F11回到上一层

​            e)调试窗口配置
​                   <img src="http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211118173148251.png" alt="image-20211118173148251" style="zoom: 67%;" />

​           <img src="http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211118174029171.png" alt="image-20211118174029171" style="zoom: 50%;" /> 			                   

​	    		![image-20211121105317999](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211121105317999.png)

​				 dug --包含调试信息--编译选项里是-Z

​					![image-20211121130329953](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211121130329953.png)

插件设置：
​						<img src="C:\Users\恒\AppData\Roaming\Typora\typora-user-images\image-20211118174728562.png" alt="image-20211118174728562" style="zoom: 50%;" /><img src="http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211118174857174.png" alt="image-20211118174857174" style="zoom: 50%;" />

f)、浮点数不支持16进制的查看，目前查看的方式有：
                1、watch 先直接查看地址 ，watch窗口：可以求表达式值，
                      delete删除上次查看的信息，**内存窗口输入地址**watch查看的地址，直接查看
                2、内存窗口中输入？（表示无内存）直接从watch窗口把**地址拖到内存显示窗口**
                3、内存窗口也支持表达式求值

## 二、条件判断

  1、条件判断
              if...else与switch区别和使用场景：

​      1、判断条件差异；if..else可以判断区间，(网络连接，文件打开关闭等事件驱动）
​                                                switch 只能判  断等于，比较单一.
​              2、复杂条件差异：if..else也由于switch
​              3、优先级差异：if..else更灵活
​                                   （判断成绩90-60，可以调整优先判断顺序）
​                                      窗口应用程序以消息驱动事件，应用频繁消息判断，鼠标和时钟；消息刷新，打
​                                      开文件闭等判断，体现出了优先级判断顺序。比较灵活。  
​              4、缺点是判断的最后一个分支效率最低。（所以的分支没优化）

​       问题总结：
​                             代码规范：
​                             if单分支;  if..后面必须带{}；若不带{}printf是个宏，宏展开多条语句很难调试
​         2、switch...case
​                          作用：机会均等，分支名中
​                          原理：switch是编译器专门来解决分支概率均优化问题，让每个分支效率等价
​                                       优化版的多分支，由于优化过，所以欠缺灵活。（只能单一判断）

​                  优化思路：它不像if的阶梯优化思路，它内置了4套优化方案
​                                              **随机访问**：访问某种介质，代价均等，这种数据结构或者存储介质就叫随机
​                                                                   访问 （内存，CD  光盘等）
​                                              **顺序访问**：磁带（稳定可靠便宜）缺点是查询缓慢

​                                                          1、case 地址代码表（数组：由特点决定支持随机访问）
​                                                                       ![image-20211118185510610](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211118185510610.png)

​                  switch...分支

## 三、循环

1、Go...to: 可以造循环；编译器中的循环就是用go...to 实现。
                           应用场景：
                          1、一层循环满足条件提前终止可用break跳出循环，
                                二层循环，内存循环提前终止，跳到所有循环的最外层，可以给内部循环里设置个标
                                志，外部循环检查标志后符合，再次break;，即可跳出
                                十层多层循环，条件最外层，就只有go...to了
         2、c语言处理条件异常，只能用go...to才可以实现，大跳转。
               c++有个抛异常机制，不用go...to了![image-20211119102719259](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211119102719259.png)

while 满足条件不转易
do...while 满足条件发生转移

![image-20211119103009034](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211119103009034.png)

do...while  和机器编译器的条件判断一致，
         while   for  都是反向判断

![image-20211119103544077](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211119103544077.png)

while 判断2次
        for  判断3次
        do  wile 判断一次

## 四、回车换行

```
回车”（Carriage Return）和“换行”（Line Feed）这两个概念的来历和区别。

符号        ASCII码        意义

\n          10          换行

\r          13    回车CR回到当前行的行首，而不会换到下一行，如果接着输出的话，本行以前的内容会被逐一覆盖
```

10000！数组 

##  附录：作业

#### 一、[grammar](javascript:;)

- [ ] ```
  1．	输入两个数，判断两个数的关系是“大于”、“等于”或“小于”，
  
  3．	判断ax^2+bx+c=0 (a!=0)方程的有几个解，如果有解则输出如果无解则输出无解。系数a、b、c由键盘输入。 
  4．	要求输出如下菜单
                     主菜单
  ================================
   		1. 输入功能 
    		2. 按学号查找
   		3. 打印输出
    		0. 退出
  ================================
   	请选择 (0~3):
             
              如果选择1，则显示“请输入”；选择2，则显示“请输入查找学生学号”；选择3，显示“正在输出”；选择0，显示“谢谢使用”；选择其它则显示“输入错误”。（用switch语句实现）。
  
  实验
  
  1. 编写一个程序求c =a+ | b | , 输出c 的值, 其中a和b为整数
       ( 绝对值函数请查函数库中的math.h 文件)
   2. 写出下面程序的输出结果
    #include <stdio.h>
    void main( )
    {  int x , y , z ;
       x = -3+4*5-6 ;     printf(“x=%d\n”, x);
       y = -3*4%-6/5 ;  printf(“y=%d\n”, y);
       z = (7+6)%5/2 ;    printf(“z=%d\n”, z);
       x = 3 ;
       y = + +x -1;   printf(“x=%d,y=%d\n”, x , y);
       z = x - - +1 ;   printf(“x=%d,z=%d\n”, x , z);
     } 
  
   3. 求出下列表达式的值
   假设 x = 3, y = 4, z = 4  
   (1) (z >= y >= x)? 1 : 0    
   (2) z>=y && y>=x
   假设 x = 3, y = 2, z = 1
   (3)  x < y ? x++ : y++     
   (4)  z +=(x < y? x++ : y++) 
  
  /*1．	
  输入两个数，判断两个数的关系是“大于”、“等于”或“小于”，并输出结果。 
  
  */
  #include<stdio.h>
  int main()
  {
  	int a =0; 
  	int b =0;
  	scanf("%d\n %d\n",&a,&b);
  	if(a>b)
  	{
  		printf("a>b");
  	}else if(a<b)
  	{
  		printf("a<b");
  	}
  	else
  	{
  		printf("a=b");
  	}
  }
  
  ```

​			

#### 二、[daily](javascript:;)

- [ ] ```
  1、图文并茂讲解switch
  2、模拟fow while do...while
  3、做个空心菱形
  4、输入一组用户名输入一组密码后提示输入正确还是错误如果错误3次就退出
  ```

  

​     

# Day 5（函数）

## 一、内存结构

![image-20211119111238974](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211119111238974.png)          操作系统， 处理器 ，最关键的4个属性，可读，可写，可执行，可共享（线程)，
          已初始化数据-->分为2种，可读写（variable&自定义数据类型）、可读(const、 常量)，    
          未初始化数据-->为可读写
          操作系统管理数据不按照业务逻辑，上下文关系分类，而是按照其同属性分类；
          应用：winhex中搜索字符串常量，可找到未加密密码

## 二、函数

##### 1、分析函数的内存结构、函数的数据结构、以及函数之间执行调用过程，

栈：为了记录函数之间的调用关系，采用后进先出。这种结构叫栈
			![image-20211120061445200](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211120061445200.png)

![image-20211120072748296](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211120072748296.png)

<img src="http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211120072415651.png" alt="image-20211120072415651" style="zoom: 67%;" />

```c
#include<stdlib.h>
#include<stdio.h>

int foo(int x, int y)
{
    return x+y;
}
void main(int argc)
{
	/* 
	每种语言都有自己的调用约定，但是细节都是这四个。
	跨平台约定有2种：
	1、c约定，
	2、标准约定，


   一、按照调用约定传递参数
			1.1调用函数是需要调用方（caller)和被调方（callee)约定:
			  参数的传递顺序，
			  参数的存储媒介，
	 		  参数的释放职责，
			  返回值的存储位置

			  返回值大多数情况在处理器中，除过特殊情况。
		
			  _cdecl约定：（c约定）
			  参数从右向左的顺序传递
			  参数使用栈空间保存
			  调用方负责清理参数空间；
		  
			   支持不定参数调用是由于调用方清理空间，（所以可以做多参数）
			   printf()不定参数

			   -stdcall约定：
			  参数从右向左的顺序传递
			  参数使用栈空间保存
			  调用方负责清理参数空间；

			  __fastcll约定：（寄存器）
			  参数从有往左的顺序传递,
			  左起前两个参数使用寄存器空间保存，其余参数使用栈保存
			  被调放负责清理参数空间


			  --thiscall约定：三阶段讲 成员函数调用


			   C语言判断同一个函数方法：
			   1、同调用约定；
			   2、同函数，才是同一个函数，否则不是；
			   c++判断同一个函数方法：
				  1、同调用约定；
				  2、同函数，
				  3、同参数序列（类型，个数），
				  4、同返回值才是同一个函数。
			   如果调用约定不同，在编译阶段，语法不会出错，但是链接阶段（链接标准库）会出错
			  
			  编译器是如何判断同调用约定，同名函数的？
			  方法： 名称粉碎：
					 __main@4（参数所占空间大小）

			  传参是个复制保存过程，


	二、在栈顶保存返回地址
	三、保存调用方的栈底
	四、更新当前栈底到栈顶位置
	五、申请局部变量空间： 请的空间小于等于申请的空间。（举例：一个房间，被2人分时间段使用，达到优化。）
		 2、禁用优化（就是调试版）的时候，申请的空间大于等于我们所有局部变量总和。
  
	
	  1-5的步骤顺序不能换，不然就乱了,6-7,不会影响内存结构

	  调试版:在申请空间时填充一个未初始化的值cc=烫，为了调试者观察方便，0只不方便，因为变量也可能会是0值；反映 2个问题：
	  1、说明是dbug版编译的，不是dbug不会烫残留值
	  2、访问了未初始化的数据；

	六、保存寄存器环境；
	                   调用函数和，被调函数 有些重要值要放入寄存器中处理，在放入前要对其进行保存，不然
					   最后被寄存器修改后。在函数回家前可以按照这个保存值进行环境还原。
	七、debug选项组会将局部变量的初值设定为0xccccccc（这一步会造成有debug正常,relec不正常这种情况）

	八、执行函数体
	九、恢复寄存器环境
	十、释放局部变量空间
	十一、恢复调用方的栈底
	十二、释放参数
	              1、如果是_cdcl约定，弹出栈顶位置存放的值作为返回地址。由调用方释放空间参数
				  2、其他调用约定，弹出栈顶位置存放的值作为返回地址，并由被调放释放参数空间。
	
	*/
    foo(1,2);
	system("pause");
    return 0;
}
```

![image-20211120075943518](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211120075943518.png)



<img src="http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211120090227926.png" alt="image-20211120090227926" style="zoom:33%;" /><img src="http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211120090527502.png" alt="image-20211120090527502" style="zoom:33%;" />

![image-20211120091021728](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211120091021728.png)

##### 2、函数的三大作用

​	   1、复用性
​              2、划分责任
​              3、 规范接口

## 附 录：作业

#### 一、[grammar](javascript:;)

```
1.	写一个函数int prime(int x)，如果x是素数返回值为1，否则返回0。并用主函数验证它。 
2.	写一个函数power(double x, int n)，其返回值为x的n次方，并用此函数计算1.5 3。
3.	求1到10共10个数中取出3个不同的数，共有多少种组合方式？
     算法：使用数学中的组合公式，其中m=10,n=3。

```

#### 二、[daily](javascript:;)

```
笔记：
0、笔记要求图文并茂、勾画出最少三层结构函数a调用b，b调用c，c等等【高版本不是固定地址，可以%p打印出来c函数中的变量地址【最内层某个内存地址，说一说经历了什么】，根据这个地址把推测其它的，来演示】，可以设置若干函数变量【讲过的变量都可以用，指针和结构体除外】。先看自己的三层，再看别人的三层。
作业：
1、输入用户名和密码，验证是否正确，如果正确提示“登录成功”，否则提示“登录失败”，三次失败后，强制退出。
2、账号密码问题考虑反制一下，要求不能使用第三方的保护代码。
3、大数阶乘问题做到秒杀：提示4位4位。
4、绘制五角星。
5、下节课讲递归。11-14homework。有一道题有坑 。不能改题目要求。不改题目原型。1-4题。先预习。
学习方法：少想、多做、少猜。学习方法。语法题不会的速度刷。

```



# Day 6（递归循环差异性）

强内聚：一切资源自理；低耦合：减少依赖
		 程序逻辑（业务）和用户界面分离
        在程序逻辑中，业务和算法分离

## 一、递归

![image-20211122183432615](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211122183432615.png)

最内层必须有结果，只有这样后面的递归才能计算。设计递归，最先考虑的是最内侧的结果是什么？有外出逐渐拨，直到找到内层给出答案的模型，返回时带上条件即可。
斐波那契数列：递推的方法定义：*F*(0)=0，*F*(1)=1, *F*(n)=*F*(n - 1)+*F*(n - 2)（*n* ≥ 2，*n* ∈ N*）
递归不适合解线性问题。适合多结果问题。
循环适合解决单一结果的线性问题。
能用循环的就可以用递归，能用递归的也能用循环。

------

挖金币游戏；递归
1、每次面临4种选择，如果递归到内存，还是无解，就返回继续一下个选择。知道找到结果。

![ ](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211122221346946.png)

## 二、循环



## 附录：作业

```
1、分别用递归和循环解决迷宫问题（递归必做，循环是选做题）。
2、动态存储管理系统。（周期：11月23号到11月29号。共计6天）。
笔记：
提交每日笔记
```



# Day 7 （数组）

一、下标运算；需要一个操作数为整数，另一个操作数位地址。
					数组名是数组第0个元素的地址常量；

## 附录：作业

```
作业：
1、寻找随机入口点
   a、定义一个局部数组 int ary[5] 。
   b、通过Memory窗口观察0x00400000【基址】（5A 4D）。
   c、基址+0x31处（0x0040003C：基址往后数4行减去4个字节的位置）【命名：地址1】。
   d、在0x0040003C【地址1】处取4个字节对应的数值。
   e、定位到对应的地址【命名：地址2】（0x00400000【基址】加上0x0040003C【地址】处取的4个字节的数值），在【地址2】处取出4个字节（验证是否是00 00 45 50）。
   f、再往下找两行半(【地址2】+0x28处)的位置【命名：地址3】,在【地址3】处取4个字节数据，把这4个字节的数据加上【基址】，计算出的结果【命名：地址4】，【地址4】就是程序执行的入口（mainCRTStartup的第一行指令）。
   g、验证：打开栈窗口，点开main函数的上一层（mainCRTStartup），在入口点的左边花括号处打断点（118行处打断点），F5运行，然后alt+8快捷键查看是跟地址4相同，以及对应的数值是否相同。（手工验证完成）
   h、最后代码实现：查询自身入口点位置。

2、优化折半查找算法（如果没有写过的，把常规的冒泡、折半、选择实现一遍）。

3、洗牌算法（基于随机点名系统：先完成排序，再查找）。

4、下标运算的本质：取0x00400042地址处的内容，并用int型输出。【ps：把随机基质关闭或者用vc6.0，】。

5、动态存储管理项目
规定数组
 char g_szBuf[0x5000]

今日作业提示：
	位运算 


笔记：
提交每日笔记

Ps：语法题薄弱的，速度刷，账号密码登录系统用可逆算法加不可逆算法优化。
语法题：
1.	已知一个数组a[5]={1,2,3,4,5}、b[5]={11,4,2,7,9}数组c[5]等于数组a、b对应元素之和。输出数组c中个元素的值。
2.	写一个函数void change(int array[],int n)，可以将数组array中的n个元素逆序存放。即array[0]与a[n-1]互换，array[1]与array[n-2]互换……。
3.	求两个矩阵的乘积c。已知矩阵a、b的值： 
4.	应用数组实现输入年year、月month、日date，计算该日期是这年的第几天。方法：定义二维数组days_of_month[2][12]，令该数组第一行由非闰年的12个月的天数组成，第二行由闰年12个月的天数组成，则根据年判断：闰年时i为1、非闰年时i为0，累计days_of_month[i][0]到days_of_month[i][month-1]的天数，再加上date，得到总天数。
5.	根据例7.10的算法，修改例7.8，要求按照平均成绩从高到低的顺序输出学号和平均分。提示：对平均分aver排序，当aver元素互换时，学号num元素对应互换。
6.	如果选择1，调用例7.9的输入函数input()；选择2，调用void search(long num[],float aver[],int n)，该函数可以根据输入的学号输出该学生的各课成绩和平均分；选择3，调用例7.9的输出函数output()；选择0，显示“谢谢使用”；选择其它则显示“输入错误，请重新输入”。
      该程序只有当输入选择为“0”时结束，否则返回主菜单 
7.	编写一个函数string_change(char str[])，要求实现str中的字符的互换。如”abcde”换成”edcba”。
8.	编写一个函数char_search(char str[],char c)，如果字符串str中包含字符c则返回数值1，否则返回数值0。
9.	编写一个函数string_cut(char string[],char c)，其功能是删除字符串中所有的字符变量c，例如
       char string=“abaca”; char c=’a’;
       则执行string_cut(string,c)后，string的内容变为”bc”。
10.	编写一个函数string_search(char str1[],char str2[])，如果字符串str1中包含字符串2则返回数值1，否则返回数值0

11.	写一个函数int prime(int x)，如果x是素数返回值为1，否则返回0。并用主函数验证它。 
12.	写一个函数power(double x, int n)，其返回值为xn，并用此函数计算1.53。


13.	用递归算法编写求Fibonacci数列第n项值的函数fib(int n)，并用主函数输出它的前20项来验证该函数



14．	定义3个整型变量及指向整型变量的指针变量，利用3个指针变量完成数据的输入、从小到大排序、输出。

15．	已知一个整型数组a[10]，要求定义2个指向整型变量的指针变量max、min，使得它们分别指向数组的最大数和最小数。

16．	编写一个函数int palindrome(char *string)，如果字符串string是回文，返回值为1，否则为0。“回文”指顺读、逆读都一样的字符串，例如”12321”、”abba”。

17．	编写一个函数string_in(char *str1,char *str2)，如果字符串str1中包含字符串str2，则返回数值1，否则返回数值0。

18．	编写一个求子串的函数sub_str(char *s1,char s2[],int m,int n)，其作用是将字符串s1中从第m个字符开始的n个字符放入字符串s2中。

19．	修改函数string_cut(char *string,char c)，要求返回值为字符串的地址。
20．	编写并验证去掉字符串中前导空格的函数char *head_cls(char *str)。
21．	修改例11.9，已知学生库char *name[6] = {“Join”, ”Mary”,”Lily”,”Bob”,”Williams”,”White”};要求根据输入学生姓名查找该学生是第几个。
22．	利用main函数可以读取命令行参数，建立文件like.c。当命令行有2个参数时，例如like football ，输出Do you like football? 当命令行有3个参数时，例如like  football  basketball 时，输出Do you like football or basketball? 当命令行有4个以上参数时，例如like C Vb Foxpro Java 时输出Do you like C,Vb,Foxpro or Java?

```

# Day 8

折半查找
![image-20211124214122829](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211124214122829.png)

## 附录：作业

多维数组：数组在内存中的排列都是一样的。没差异。
                             本质还是数组中的数组，
									内存结构和一维数组相同，每个元素地址相邻。数据类型一致
									不能按照行列式去理解。
									所有数组的特点：连续（内存地址）且一致（数据类型一致）

作业：
1、用筛选法求100以内的素数。
2、求3到21之间的幻方。（行和列是奇数，偶数的暂时不要求）

笔记：
提交每日笔记

明天讲课内容：
字符、字符串。（函数不讲：例如，puts等，掌握不清晰的需要预习一下）


Ps：折半的应用：利用平方根提升效率，同时考虑存在double类型的数据、做着玩玩。项目每天的日志、和计划别忘记提交。


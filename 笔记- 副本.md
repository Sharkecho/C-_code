<p align="left">C语言</p>

[toc]

# Day 1（基础思路很简单，**细节是魔鬼**）

## 一、设置win10添加右键菜单 打开CMD命令行工具

HKEY_CLASSES_ROOT\Directory\Background\shell，
        ShowBasedOnVelocityId
        cmd.exe /s /k pushd "%V"
        E:\works\setting\icon.ico 

<img src="C:\Users\恒\AppData\Roaming\Typora\typora-user-images\image-20211115190023962.png" alt="image-20211115190023962"  />

## 二、编译器、链接器

<img src="C:\Users\恒\AppData\Roaming\Typora\typora-user-images\image-20211116082638578.png" alt="image-20211116082638578" style="zoom:33%;" />

​       编译：把人方便阅读的代码翻译成机器代码，
​       链接：按照平台要求，组织数据、代码放在系统可以识别的要求位置。以及其
​                    它条件。
​       cl（可以跨平台） Link(各平台不同)

## 三、命令行执行C code

```
windows下,cl  /c仅编译不链接， 无/c就是编译链接都做完
​ cl + /c + 目标文件
```

## 四、include "" <> 区别

 	1、""查找文件目录外加环境变量
 	2、<>只找环境变量

## 五 、输入输出函数的各种用法

### 1、  printf()

```
          **函数原型**
​          include <stdio.h>
​          int printf(const char *format, ...);
​          返回值
​     	 **Return Value**
​          Each of these functions returns the number of characters printed, or a      negative value if an error occurs.

​            printf 的格式有四种：
​            1、printf("字符串\n");
​            2、printf("输出控制符"，输出参数);
​            3、printf("输出控制符1 输出控制符2…", 输出参数1, 输出参数2, …); 
​            4、printf("输出控制符 非输出控制符"，输出参数);   

<​          **函数原型**
​          include <stdio.h>
​          int printf(const char *format, ...);
​          返回值
​     	 **Return Value**
​          Each of these functions returns the number of characters printed, or a      negative value if an error occurs.

​            printf 的格式有四种：
​            1、printf("字符串\n");
​            2、printf("输出控制符"，输出参数);
​            3、printf("输出控制符1 输出控制符2…", 输出参数1, 输出参数2, …); 
​            4、printf("输出控制符 非输出控制符"，输出参数);   


```

<img src="C:\Users\恒\AppData\Roaming\Typora\typora-user-images\image-20211116074522597.png" alt="image-20211116074522597"  /> 

getc,  getwc, getchar, getwchar

### <span style='background:yellow'>0、getc用法：</span>   

Each of these functions returns the character read. To indicate an read error  or end-of-file condition, **getc** and **getchar** return **EOF**, and  **getwc** and **getwchar** return **WEOF**. For **getc** and  **getchar**, use **ferror** or **feof** to check for an error or for  end of file
### <span style='background:yellow'>1、getchar用法：</span>   
getchar()C标准库提供的输入输出模型，都是按照字符流的方式处理
getchar()是最简单的一次读一个字符的函数，每次调用时从文本流中读入下一个字符，并将其作为结果值返回。
但是，注意的是，返回值是int型！即:

```text
int c;
c = getchar();
为什么不能是char型呢？ 
```

因为，在没有输入或者输入字符有错的时候，getchar()函数将返回一个特殊值，这个特殊值与任何实际字符都不同，称为EOF(end of file,文件结束)。EOF是定义在头文件

```c
#include <stdio.h>
main()
{
    int c;
    c = getchar();
    while(c != EOF)
    {
        putchar(c);
        c = getchar();
    }
}
```

是正确的！

当程序调用getchar()时，程序就等着用户按键。用户输入的字符被存放在键盘缓冲区中，直到用户按回车为止(回车字符也放在缓冲区中)。

当用户键入回车之后，getchar()才开始从输入流中每次读入一个字符，getchar()函数的返回值是用户输入的第一个字符的ASCII码,如出错返回EOF。如用户在按回车之前输入了不止一个字符，其他字符会保留在键盘缓存区中,，待后续getchar()调用读取。也就是说，后续的getchar()调用不会等待用户按键，而直接读取缓冲区中的字符，直到缓冲区中的字符读完为后，才等待用户按键。

getch与getchar的基本功能相同，不同就在于getch（所在头文件：conio.h）不等待回车，只要按下按键就会返回该键字符所对应的ASCII码。输入字符不回显。

Q:getchar()!=EOF的值？

Q:EOF的值？

```c
#include <stdio.h>
int main()
{
     int c;
     while(c = getchar() != EOF)
     {
        printf("%d\n",c);
     }
     printf("%d\n",c);
     printf("EOF = %d\n",EOF);
    return 0;
}
```

结果：

getchar()!=EOF的值为1；

EOF=-1;

```text
注： 
```

ctr-D:是一个特殊的二进制值，表示 EOF。

ct-Z:中断命令。

**从缓冲区读走一个字符，相当于清除缓冲区**

2.前面的scanf()在读取输入时会在缓冲区中留下一个字符'\n'（输入完s[i]的值后按回车键所致），所以如果不在此加一个getchar()把这个回车符取走的话，gets(）就不会等待从键盘键入字符，而是会直接取走这个“无用的”回车符，从而导致读取有误

3.getchar()是在输入缓冲区顺序读入一个字符(包括空格、回车和Tab)

getchar()使用不方便,解决方法：

（1）使用下面的语句清除回车：

```text
while(getchar()!='\n');   
```

（2**）用getche()或getch()代替getchar()，其作用是从键盘读入一个字符（不用按回车），注意要包含头文件<conio.h>**

## 七、代码规范

```http
windows:匈牙利    微软
linux:  —下划线是linux规范
int n,i;
float f,flt;
double d,dbl;
char c，
```
## 八、字符串指针

## 九、整数与字符串的相互转换

​               1、拓展函数 itoa
​		           itoa (表示 integer to alphanumeric)是把整型数转换成字符串的一个函数。
​                 windows 环境下，在 <stdlib.h> 头文件中有:
​                    

```http
char* itoa(int value,char*string,int radix);
//value: 要转换的整数，string: 转换后的字符串,radix: 转换进制数，如2,8,10,16 进制等。
```

```c
源码：
char* itoa(int num,char* str,int radix)
{
    char index[]="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";//索引表
    unsigned unum;//存放要转换的整数的绝对值,转换的整数可能是负数
    int i=0,j,k;//i用来指示设置字符串相应位，转换之后i其实就是字符串的长度；转换后顺序是逆序的，有正负的情况，k用来指示调整顺序的开始位置;j用来指示调整顺序时的交换。
 
    //获取要转换的整数的绝对值
    if(radix==10&&num<0)//要转换成十进制数并且是负数
    {
        unum=(unsigned)-num;//将num的绝对值赋给unum
        str[i++]='-';//在字符串最前面设置为'-'号，并且索引加1
    }
    else unum=(unsigned)num;//若是num为正，直接赋值给unum
 
    //转换部分，注意转换后是逆序的
    do
    {
        str[i++]=index[unum%(unsigned)radix];//取unum的最后一位，并设置为str对应位，指示索引加1
        unum/=radix;//unum去掉最后一位
 
    }while(unum);//直至unum为0退出循环
 
    str[i]='\0';//在字符串最后添加'\0'字符，c语言字符串以'\0'结束。
 
    //将顺序调整过来
    if(str[0]=='-') k=1;//如果是负数，符号不用调整，从符号后面开始调整
    else k=0;//不是负数，全部都要调整
 
    char temp;//临时变量，交换两个值时用到
    for(j=k;j<=(i-1)/2;j++)//头尾一一对称交换，i其实就是字符串的长度，索引最大值比长度少1
    {
        temp=str[j];//头部赋值给临时变量
        str[j]=str[i-1+k-j];//尾部赋值给头部
        str[i-1+k-j]=temp;//将临时变量的值(其实就是之前的头部值)赋给尾部
    }
 
    return str;//返回转换后的字符串
 
}
```

```c
实例：
#include <stdlib.h>
#include <stdio.h>
int main()
{
    int number1 = 123456;
    int number2 = -123456;
    char string[16] = {0};
    itoa(number1,string,10);
    printf("数字：%d 转换后的字符串为：%s\n",number1,string);
    itoa(number2,string,10);
    printf("数字：%d 转换后的字符串为：%s\n",number2,string);
    return 0;
}

```

​		





## 附录（作业）

# Day 2

##  一、窗口暂停使用：

```http
跨平台：gechar();
win（dos专用)：system();        #include <stdlib.h>
```

## 二、计算机内存管理方式与如何查看内存数据

​          小尾存储：PC 移动设备  低地址存低数据位，高地址存高数据位。主流
​          大端存储：大型机
​          内存管理：最小管理单位（4字节）
​                               以 字节为单位，搜索太慢，所以每个变量的首地址都是4的倍数
​			![image-20211117090740813](C:\Users\恒\AppData\Roaming\Typora\typora-user-images\image-20211117090740813.png)

自动编译bat脚本：

```
的
```



## 三、计算机如何通过位运算处理四则运算？

​           1、&、
  	     2、|
​           3、^
​           4、~

​       <span style=" background:yellow;">**计算机用移位和加法表示乘法**</span>
$$
A*18 = A * (1000 + 10)
\\
                         10000A + 10A
                         \\
                          A<<4+A<<2
                          \\
            n进制分解成 n^n  次幂累加；
$$

​	     <span style=" background:yellow;">**计算机除法原型**</span>    
$$
\frac{A}{C}=A*\frac{1}{C}=A*\frac{2^N}{C}*\frac{1}{2^N}
\\
M=\frac{2^N}{C}
\\
AM >>N
$$
​          <span style=" background:yellow;">**计算机减法实现原理**</span>  
​                               
$$
A-B(假定单字节)
\\
A + (100h-B)-100h
\\
B+ `B =FF
\\
B+`B+1=100h
\\
   `B+1=100h-B
   \\
A+`B+1-100h = A-B
\\
A+neg(B)-100h
$$

  ## 四、负数的存储

​	 补码：是编码（用来表达有符号数），双方协定的协议，反码+1
​            求补：法则，对值进行取反+1；
​	         最高有效位，记录符号，其余位记录数据

```txt
一. 机器数和真值
在学习原码, 反码和补码之前, 需要先了解机器数和真值的概念.

1、机器数
一个数在计算机中的二进制表示形式,  叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1.

比如，十进制中的数 +3 ，计算机字长为8位，转换成二进制就是00000011。如果是 -3 ，就是 10000011 。

那么，这里的 00000011 和 10000011 就是机器数。

2、真值
因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。

例：0000 0001的真值 = +000 0001 = +1，1000 0001的真值 = –000 0001 = –1

 

二. 原码, 反码, 补码的基础概念和计算方法.
在探求为何机器要使用补码之前, 让我们先了解原码, 反码和补码的概念.对于一个数, 计算机要使用一定的编码方式进行存储. 原码, 反码, 补码是机器存储一个具体数字的编码方式.

1. 原码
原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制:

[+1]原 = 0000 0001

[-1]原 = 1000 0001

第一位是符号位. 因为第一位是符号位, 所以8位二进制数的取值范围就是:

[1111 1111 , 0111 1111]

即

[-127 , 127]

原码是人脑最容易理解和计算的表示方式.

2. 反码
反码的表示方法是:

正数的反码是其本身

负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.

[+1] = [00000001]原 = [00000001]反

[-1] = [10000001]原 = [11111110]反

可见如果一个反码表示的是负数, 人脑无法直观的看出来它的数值. 通常要将其转换成原码再计算.

3. 补码
补码的表示方法是:

正数的补码就是其本身

负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)

[+1] = [00000001]原 = [00000001]反 = [00000001]补

[-1] = [10000001]原 = [11111110]反 = [11111111]补

对于负数, 补码表示方式也是人脑无法直观看出其数值的. 通常也需要转换成原码在计算其数值.

 三. 为何要使用原码, 反码和补码
在开始深入学习前, 我的学习建议是先"死记硬背"上面的原码, 反码和补码的表示方式以及计算方法.

现在我们知道了计算机可以有三种编码方式表示一个数. 对于正数因为三种编码方式的结果都相同:

[+1] = [00000001]原 = [00000001]反 = [00000001]补

所以不需要过多解释. 但是对于负数:

[-1] = [10000001]原 = [11111110]反 = [11111111]补

可见原码, 反码和补码是完全不同的. 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢?

首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别"符号位"显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.

于是人们开始探索 将符号位参与运算, 并且只保留加法的方法. 首先来看原码:

计算十进制的表达式: 1-1=0

1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2

如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数.

为了解决原码做减法的问题, 出现了反码:

计算十进制的表达式: 1-1=0

1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原= [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0

发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在"0"这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0.

于是补码的出现, 解决了0的符号以及两个编码的问题:

1-1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补=[0000 0000]原

这样0用[0000 0000]表示, 而以前出现问题的-0则不存在了.而且可以用[1000 0000]表示-128:

(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补

-1-127的结果应该是-128, 在用补码运算的结果中, [1000 0000]补 就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的)

使用补码, 不仅仅修复了0的符号以及存在两个编码的问题, 而且还能够多表示一个最低数. 这就是为什么8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127].

因为机器使用补码, 所以对于编程中常用到的32位int类型, 可以表示范围是: [-231, 231-1] 因为第一位表示的是符号位.而使用补码表示时又可以多保存一个最小值.

 四 原码, 反码, 补码 再深入
计算机巧妙地把符号位参与运算, 并且将减法变成了加法, 背后蕴含了怎样的数学原理呢?

将钟表想象成是一个1位的12进制数. 如果当前时间是6点, 我希望将时间设置成4点, 需要怎么做呢?我们可以:

1. 往回拨2个小时: 6 - 2 = 4

2. 往前拨10个小时: (6 + 10) mod 12 = 4

3. 往前拨10+12=22个小时: (6+22) mod 12 =4

2,3方法中的mod是指取模操作, 16 mod 12 =4 即用16除以12后的余数是4.

所以钟表往回拨(减法)的结果可以用往前拨(加法)替代!

现在的焦点就落在了如何用一个正数, 来替代一个负数. 上面的例子我们能感觉出来一些端倪, 发现一些规律. 但是数学是严谨的. 不能靠感觉.

首先介绍一个数学中相关的概念: 同余

 

同余的概念
两个整数a，b，若它们除以整数m所得的余数相等，则称a，b对于模m同余

记作 a ≡ b (mod m)

读作 a 与 b 关于模 m 同余。

举例说明:

4 mod 12 = 4

16 mod 12 = 4

28 mod 12 = 4

所以4, 16, 28关于模 12 同余.

负数取模
正数进行mod运算是很简单的. 但是负数呢?

下面是关于mod运算的数学定义:

clip_image001

上面是截图, "取下界"符号找不到如何输入(word中粘贴过来后乱码). 下面是使用"L"和"J"替换上图的"取下界"符号:

x mod y = x - y L x / y J

上面公式的意思是:

x mod y等于 x 减去 y 乘上 x与y的商的下界.

以 -3 mod 2 举例:

-3 mod 2

= -3 - 2xL -3/2 J

= -3 - 2xL-1.5J

= -3 - 2x(-2)

= -3 + 4 = 1

所以:

(-2) mod 12 = 12-2=10

(-4) mod 12 = 12-4 = 8

(-5) mod 12 = 12 - 5 = 7

 
开始证明
再回到时钟的问题上:

回拨2小时 = 前拨10小时

回拨4小时 = 前拨8小时

回拨5小时= 前拨7小时

注意, 这里发现的规律!

结合上面学到的同余的概念.实际上:

(-2) mod 12 = 10

10 mod 12 = 10

-2与10是同余的.

(-4) mod 12 = 8

8 mod 12 = 8

-4与8是同余的.

距离成功越来越近了. 要实现用正数替代负数, 只需要运用同余数的两个定理:

反身性:

a ≡ a (mod m)

这个定理是很显而易见的.

线性运算定理:

如果a ≡ b (mod m)，c ≡ d (mod m) 那么:

(1)a ± c ≡ b ± d (mod m)

(2)a * c ≡ b * d (mod m)

如果想看这个定理的证明, 请看:http://baike.baidu.com/view/79282.htm

所以:

7 ≡ 7 (mod 12)

(-2) ≡ 10 (mod 12)

7 -2 ≡ 7 + 10 (mod 12)

现在我们为一个负数, 找到了它的正数同余数. 但是并不是7-2 = 7+10, 而是 7 -2 ≡ 7 + 10 (mod 12) , 即计算结果的余数相等.

接下来回到二进制的问题上, 看一下: 2-1=1的问题.

2-1=2+(-1) = [0000 0010]原 + [1000 0001]原= [0000 0010]反 + [1111 1110]反

先到这一步, -1的反码表示是1111 1110. 如果这里将[1111 1110]认为是原码, 则[1111 1110]原 = -126, 这里将符号位除去, 即认为是126.

发现有如下规律:

(-1) mod 127 = 126

126 mod 127 = 126

即:

(-1) ≡ 126 (mod 127)

2-1 ≡ 2+126 (mod 127)

2-1 与 2+126的余数结果是相同的! 而这个余数, 正式我们的期望的计算结果: 2-1=1

所以说一个数的反码, 实际上是这个数对于一个膜的同余数. 而这个膜并不是我们的二进制, 而是所能表示的最大值! 这就和钟表一样, 转了一圈后总能找到在可表示范围内的一个正确的数值!

而2+126很显然相当于钟表转过了一轮, 而因为符号位是参与计算的, 正好和溢出的最高位形成正确的运算结果.

既然反码可以将减法变成加法, 那么现在计算机使用的补码呢? 为什么在反码的基础上加1, 还能得到正确的结果?

2-1=2+(-1) = [0000 0010]原 + [1000 0001]原 = [0000 0010]补 + [1111 1111]补

如果把[1111 1111]当成原码, 去除符号位, 则:

[0111 1111]原 = 127

其实, 在反码的基础上+1, 只是相当于增加了膜的值:

(-1) mod 128 = 127

127 mod 128 = 127

2-1 ≡ 2+127 (mod 128)

此时, 表盘相当于每128个刻度转一轮. 所以用补码表示的运算结果最小值和最大值应该是[-128, 128].

但是由于0的特殊情况, 没有办法表示128, 所以补码的取值范围是[-128, 127]
```



## 五、putc与putchar区别

​    putc（int ch，FILE *fp），即将字符ch输出到fp所指的文件中；
​             putchar（char ch)，即将字符ch输出到标准输出设备上。

​    1、 putc是函数， putchar()是在stdio.h里定义的宏；
​            2、 putc是文件操作函数， 而putchar()则是设备操作

六、puts, _putws

## 六、**常量INT_MAX和INT_MIN分别表示最大、最小整数，定义在头文件limits.h中**

## 七、取模的理解&取模运算涉及的算法

> ```
> 取模运算
> 背景
> 取模运算(mod)和取余运算(rem)两个概念有重叠的部分，但又不完全一致；主要区别在于对负整数进行除法运算时操作不同。取模主要是用于计算机术语中；取余则更多是数学概念。
> 
> 取模和取余的区别
> 取余运算 在计算商值时 商值向0方向舍入；靠近0原则
> 取模运算 在计算商值时 商值向负无穷方向舍入；尽可能让商值小的原则(不超多商值的最大值)
> 计算步骤
> 假设有整数a和b，那么取模/取余运算可以分为两步运算：
> 
> 求整数商：c = a/b;
> 计算模/余数：r = a - (c*b);
> 总计算模/余数：a mod b = a - b[a/b] ([a/b]表示整数商)
> 例子
> 取模
> 
> 简述	商值		取模值
> 5 mod 3 = 2	5/3 = 1.66 商取小原则 商=1	5 - 3 * 1 = 2	2
> -5 mod 3 = 1	-5/3 = -1.66 商取小原则 商=-2	-5 - (3 * -2) = 1	1
> 5 mod -3 = -1	5/-3 = -1.66 商取小原则 商=-2	5 - (-3 * -2) = -1	-1
> -5 mod -3 = -2	-5/-3 = 1.66 商取小原则 商=1	-5 - (-3 * 1) = 2	-2
> 取余
> 
> 简述	商值		取余值
> 5 rem 3 = 2	5/3 = 1.66 商靠0原则 商=1	5 - 3 * 1 = 2	2
> -5 rem 3 = -2	-5/3 = -1.66 商靠0原则 商=-1	-5 - (3 * -1) = - 2	-2
> 5 rem -3 = 2	5/-3 = -1.66 商靠0原则 商=-1	5 - (-3 * -1) = 2	2
> -5 rem -3 = -2	-5/-3 = 1.66 商靠0原则 商=1	-5 - (-3 * 1) = - 2	-2
> java 中 % 是取余运算；Python中 % 是取模运算
> 
> 模的理解
> “模”是指一个计量系统的计数范围；如时钟，12个整点为计算范围，则模为12；计算机也是一个计量机器，模为32位或者64位；
> 
> 32位计算机正常理解 在模 范围内能表达的 有 [0, 2³²-1]；那么负数该怎么表达呢，所以出现了补码；也就是 正数 + 负数 正好达到模的溢出阀值2³²；所以在计算机中负数是用补码方式表达的原因；
> 
> 关于补码的例子：在12模的时钟中；假设当前时针指向10点,而准确时间是6点,调整时间可有以下两种拨法
> 
> 倒拨4小时,即：10-4=6 (10-4) mod 12 = 6
> 顺拨8小时：10+8=12+6=6 （10+8）mod 12 = 6
> 在以12模的系统中，加8和减4效果是一样的；因此凡是减4运算，都可以用加8来代替。对“模”而言，8和4互为补数。实际上以12模的系统中11和1、10和2、9和3、7和5、6和6都有这个特性；共同的特点是两者相加等于模
> 
> “取模”实质上是计量器产生“溢出”的量，它的值在计量器上表示不出来，计量器上只能表示出模的余数(取模)；任何有模的计量器，均可化为加减法运算
> 
> 5 mod 3 = 2 例子中；模 为 3；2 为取模的值
> 
> 计算机中取模应用思想
> 取模的本质是：取模的值，必定会模的范围内；所以，计算机领域引用该特性，使元素路由算法不超出边界，并有规则存放。
> 
> 首先确定模(范围)；元素取模，使元素有规则的落入模的范围内容器中
> 
> 如：hashMap、数据库分表、分布式节点路由算法等
> 
> 作者：蜗牛写java
> 链接：https://www.jianshu.com/p/5e1a83e8be3b
> 来源：简书
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
> ```


https://github.com/wujr5/algorithm-analysis-and-design/blob/master/relative-algorithm-learning/6-algorithm-about-modulo-operation.md


## 附录：作业

  1、使用printf() 函数显示下列菜单： 
        menu

1. Input the students’ names and scores 

2. Search scores of some students

3. Modify scores of some students

4. List all students’ scores 

5. ###### Quit the system 

​    Please input your choise (1-5): 

2.	参照例1.7和例1.8，选择一种方法编写一个程序，实现输入 
      	六个数输出最小数。 
   
3.	编写一个程序，从键盘上输入华氏温度，屏幕显示对应的
	摄氏温度。华氏温度和摄氏温度的转换公式为： 
	c=(f-32)/1.8 
	
4.  编程输出字符0、9、A、Z、a、z的ACSII码的十进制、八进制和十六进制的表示形式。 

5.  参考例L2_6.C编写一个程序，从键盘输入字符（例如’1’），转换成十进制数（即1），并输出。
    提示：“1”的ASCII码为十进制数49，将其减去一个数等于十进制1即可。 

6.  已知a=3，b=2，c=2.5，计算(float)(a+b)/3+(int)c的值。 

7.  编写一个程序输出5！、10！的结果。 

8.  参考例L2_8.C编写一个程序，输入2个学生的姓名、学号、英语、数学、计算机成绩，输出这两个学生的姓名、学号和平均分。

    ---

    1.	写出58.25的16进制
    2.	自己写程序查看float定义数据的内存。
    3.	将asscii码表打出来，并观察对应关系
    4.	写程序将36由int转为char,和double并查看其内存值
    5.	输入矩形的两个边的值(浮点型)，求其面积
    6.	写程序说明一下int和long在内存中的区别，（即数据大小）
    7.	编程说明long double、long int和double long它们在内存中的区别

# Day 3 浮点数



##  一、隐士转换问题

当表达式运算时，数据类型不匹配，会发生自动隐士转换；
​         隐士转换的本质还是数据的存储问题。
​            

排序 查找

 线性排序

scanf:作用

C 05 内存访问错误 



## 二、大数存储问题

https://www.codeleading.com/article/59656111373/

https://www.codeleading.com/article/54425639384/

所谓大数计算，差不多就是模拟你手算的过程的程序实现。

记录数据用字符串，解决办法之一就是：以个位作为参考点，像小学时代那样一位一位算即可

![img](https://img-blog.csdnimg.cn/20200413161639181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2R1anVhbmNhbzEx,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20200413161933264.png)

![img](https://img-blog.csdnimg.cn/2020041316242571.png)



##### 1、字符串转整数

```c
这个字符串参数必须包含一个或多个数字，函数应该把这些数字字符转换为整数并返回这个整数。如果字符串参数包含了任何非数字字符，函数就返回零。请不必担心算术溢出。
提示：这个技巧很简单你每发现一个数字，把当前值乘以10，并把这个值和新数字所代表的值相加。
这个问题应该用迭代方法解决，而不应采用递归方法。
#include <stdio.h>
// 把一个数字字符串转换为一个整数。
int ascii_to_integer( char *string )
{
    int value; value = 0;
    // 逐个把字符串的字符转换为数字。
    while( *string >= '0' && *string <= '9' ){
        value *= 10;
        value += *string - '0';
        string++;
    }
    //错误检查：如杲由于遇到一个非数字字符而终止，把结果设置为0
    if( *string != '\0' )
        value = 0;
    return value;
}
int main()
{
    char* numChar = "102";
    printf("%d\n", ascii_to_integer(numChar)+3);
    
    return 0;
}
```



## 三、浮点数的存储问题

## 四、内存对齐

操作系统 上下分	2G   80包含80属于操作系统

## 附录：作业

```
1、100!的阶乘。存储
```



# Day4 分支与循环

##  一、 VC6-Ide基本设置与使用

​     a)、Tool选项卡：
​                    <img src="http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211118165530877.png" alt="image-20211118165530877" style="zoom: 67%;" />
​				b)、formart选项卡：字体设置\常量颜色设置
​	                <img src="http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211118170349787.png" alt="image-20211118170349787" style="zoom:33%;" /><img src="http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211118170532826.png" alt="image-20211118170532826" style="zoom:33%;" />

​     c)、工程选项卡：
​			          <img src="http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211118171522033.png" alt="image-20211118171522033" style="zoom: 50%;" />   

​            配置文件信息都保存在工程目录下的 dsp文件 ，如果有需求修改编译选项 可自行修改       script。  
​            d)使用：
​							f7  编译+链接
​						   CTR+F7  仅编译不链接
​							 f9  设置断点
​                       f5  调试环境运行（配置F9使用）
​                       CTR+F5	脱离调试直接运行
​                              dst；里包含编译选项

​                       dsw:每个项目是一个单独一个项目，多个项目组成一个工作空间
​							  f10 单步调试（查看结果）
​            				f11 单步(查看过程)
 						SHIT+F11回到上一层

​            e)调试窗口配置
​                   <img src="http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211118173148251.png" alt="image-20211118173148251" style="zoom: 67%;" />

​           <img src="http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211118174029171.png" alt="image-20211118174029171" style="zoom: 50%;" /> 			                   

​	    		![image-20211121105317999](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211121105317999.png)

​				 dug --包含调试信息--编译选项里是-Z

​					![image-20211121130329953](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211121130329953.png)

插件设置：
​						<img src="C:\Users\恒\AppData\Roaming\Typora\typora-user-images\image-20211118174728562.png" alt="image-20211118174728562" style="zoom: 50%;" /><img src="http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211118174857174.png" alt="image-20211118174857174" style="zoom: 50%;" />

f)、浮点数不支持16进制的查看，目前查看的方式有：
                1、watch 先直接查看地址 ，watch窗口：可以求表达式值，
                      delete删除上次查看的信息，**内存窗口输入地址**watch查看的地址，直接查看
                2、内存窗口中输入？（表示无内存）直接从watch窗口把**地址拖到内存显示窗口**
                3、内存窗口也支持表达式求值

## 二、条件判断

  1、条件判断
              if...else与switch区别和使用场景：

​      1、判断条件差异；if..else可以判断区间，(网络连接，文件打开关闭等事件驱动）
​                                                switch 只能判  断等于，比较单一.
​              2、复杂条件差异：if..else也由于switch
​              3、优先级差异：if..else更灵活
​                                   （判断成绩90-60，可以调整优先判断顺序）
​                                      窗口应用程序以消息驱动事件，应用频繁消息判断，鼠标和时钟；消息刷新，打
​                                      开文件闭等判断，体现出了优先级判断顺序。比较灵活。  
​              4、缺点是判断的最后一个分支效率最低。（所以的分支没优化）

​       问题总结：
​                             代码规范：
​                             if单分支;  if..后面必须带{}；若不带{}printf是个宏，宏展开多条语句很难调试
​         2、switch...case
​                          作用：机会均等，分支名中
​                          原理：switch是编译器专门来解决分支概率均优化问题，让每个分支效率等价
​                                       优化版的多分支，由于优化过，所以欠缺灵活。（只能单一判断）

​                  优化思路：它不像if的阶梯优化思路，它内置了4套优化方案
​                                              **随机访问**：访问某种介质，代价均等，这种数据结构或者存储介质就叫随机
​                                                                   访问 （内存，CD  光盘等）
​                                              **顺序访问**：磁带（稳定可靠便宜）缺点是查询缓慢

​                                                          1、case 地址代码表（数组：由特点决定支持随机访问）
​                                                                       ![image-20211118185510610](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211118185510610.png)

​                  switch...分支

## 三、循环

1、Go...to: 可以造循环；编译器中的循环就是用go...to 实现。
                           应用场景：
                          1、一层循环满足条件提前终止可用break跳出循环，
                                二层循环，内存循环提前终止，跳到所有循环的最外层，可以给内部循环里设置个标
                                志，外部循环检查标志后符合，再次break;，即可跳出
                                十层多层循环，条件最外层，就只有go...to了
         2、c语言处理条件异常，只能用go...to才可以实现，大跳转。
               c++有个抛异常机制，不用go...to了![image-20211119102719259](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211119102719259.png)

while 满足条件不转易
do...while 满足条件发生转移

![image-20211119103009034](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211119103009034.png)

do...while  和机器编译器的条件判断一致，
         while   for  都是反向判断

![image-20211119103544077](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211119103544077.png)

while 判断2次
        for  判断3次
        do  wile 判断一次

## 四、回车换行

```
回车”（Carriage Return）和“换行”（Line Feed）这两个概念的来历和区别。

符号        ASCII码        意义

\n          10          换行

\r          13    回车CR回到当前行的行首，而不会换到下一行，如果接着输出的话，本行以前的内容会被逐一覆盖
```

10000！数组 

##  附录：作业

#### 一、[grammar](javascript:;)

- [ ] ```
  1．	输入两个数，判断两个数的关系是“大于”、“等于”或“小于”，
  
  3．	判断ax^2+bx+c=0 (a!=0)方程的有几个解，如果有解则输出如果无解则输出无解。系数a、b、c由键盘输入。 
  4．	要求输出如下菜单
                     主菜单
  ================================
   		1. 输入功能 
    		2. 按学号查找
   		3. 打印输出
    		0. 退出
  ================================
   	请选择 (0~3):
             
              如果选择1，则显示“请输入”；选择2，则显示“请输入查找学生学号”；选择3，显示“正在输出”；选择0，显示“谢谢使用”；选择其它则显示“输入错误”。（用switch语句实现）。
  
  实验
  
  1. 编写一个程序求c =a+ | b | , 输出c 的值, 其中a和b为整数
       ( 绝对值函数请查函数库中的math.h 文件)
   2. 写出下面程序的输出结果
    #include <stdio.h>
    void main( )
    {  int x , y , z ;
       x = -3+4*5-6 ;     printf(“x=%d\n”, x);
       y = -3*4%-6/5 ;  printf(“y=%d\n”, y);
       z = (7+6)%5/2 ;    printf(“z=%d\n”, z);
       x = 3 ;
       y = + +x -1;   printf(“x=%d,y=%d\n”, x , y);
       z = x - - +1 ;   printf(“x=%d,z=%d\n”, x , z);
     } 
  
   3. 求出下列表达式的值
   假设 x = 3, y = 4, z = 4  
   (1) (z >= y >= x)? 1 : 0    
   (2) z>=y && y>=x
   假设 x = 3, y = 2, z = 1
   (3)  x < y ? x++ : y++     
   (4)  z +=(x < y? x++ : y++) 
  
  /*1．	
  输入两个数，判断两个数的关系是“大于”、“等于”或“小于”，并输出结果。 
  
  */
  #include<stdio.h>
  int main()
  {
  	int a =0; 
  	int b =0;
  	scanf("%d\n %d\n",&a,&b);
  	if(a>b)
  	{
  		printf("a>b");
  	}else if(a<b)
  	{
  		printf("a<b");
  	}
  	else
  	{
  		printf("a=b");
  	}
  }
  
  ```

​			

#### 二、[daily](javascript:;)

- [ ] ```
  1、图文并茂讲解switch
  2、模拟fow while do...while
  3、做个空心菱形
  4、输入一组用户名输入一组密码后提示输入正确还是错误如果错误3次就退出
  ```

  

​     

# Day 5 函数

## 一、内存结构

![image-20211119111238974](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211119111238974.png)          操作系统， 处理器 ，最关键的4个属性，可读，可写，可执行，可共享（线程)，
          已初始化数据-->分为2种，可读写（variable&自定义数据类型）、可读(const、 常量)，    
          未初始化数据-->为可读写
          操作系统管理数据不按照业务逻辑，上下文关系分类，而是按照其同属性分类；
          应用：winhex中搜索字符串常量，可找到未加密密码

## 二、函数

##### 1、分析函数的内存结构、函数的数据结构、以及函数之间执行调用过程，

栈：为了记录函数之间的调用关系，采用后进先出。这种结构叫栈
			![image-20211120061445200](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211120061445200.png)

![image-20211120072748296](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211120072748296.png)

<img src="http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211120072415651.png" alt="image-20211120072415651" style="zoom: 67%;" />

```c
#include<stdlib.h>
#include<stdio.h>

int foo(int x, int y)
{
    return x+y;
}
void main(int argc)
{
	/* 
	每种语言都有自己的调用约定，但是细节都是这四个。
	跨平台约定有2种：
	1、c约定，
	2、标准约定，


   一、按照调用约定传递参数
			1.1调用函数是需要调用方（caller)和被调方（callee)约定:
			  参数的传递顺序，
			  参数的存储媒介，
	 		  参数的释放职责，
			  返回值的存储位置

			  返回值大多数情况在处理器中，除过特殊情况。
		
			  _cdecl约定：（c约定）
			  参数从右向左的顺序传递
			  参数使用栈空间保存
			  调用方负责清理参数空间；
		  
			   支持不定参数调用是由于调用方清理空间，（所以可以做多参数）
			   printf()不定参数

			   -stdcall约定：
			  参数从右向左的顺序传递
			  参数使用栈空间保存
			  调用方负责清理参数空间；

			  __fastcll约定：（寄存器）
			  参数从有往左的顺序传递,
			  左起前两个参数使用寄存器空间保存，其余参数使用栈保存
			  被调放负责清理参数空间


			  --thiscall约定：三阶段讲 成员函数调用


			   C语言判断同一个函数方法：
			   1、同调用约定；
			   2、同函数，才是同一个函数，否则不是；
			   c++判断同一个函数方法：
				  1、同调用约定；
				  2、同函数，
				  3、同参数序列（类型，个数），
				  4、同返回值才是同一个函数。
			   如果调用约定不同，在编译阶段，语法不会出错，但是链接阶段（链接标准库）会出错
			  
			  编译器是如何判断同调用约定，同名函数的？
			  方法： 名称粉碎：
					 __main@4（参数所占空间大小）

			  传参是个复制保存过程，


	二、在栈顶保存返回地址
	三、保存调用方的栈底
	四、更新当前栈底到栈顶位置
	五、申请局部变量空间： 请的空间小于等于申请的空间。（举例：一个房间，被2人分时间段使用，达到优化。）
		 2、禁用优化（就是调试版）的时候，申请的空间大于等于我们所有局部变量总和。
  
	
	  1-5的步骤顺序不能换，不然就乱了,6-7,不会影响内存结构

	  调试版:在申请空间时填充一个未初始化的值cc=烫，为了调试者观察方便，0只不方便，因为变量也可能会是0值；反映 2个问题：
	  1、说明是dbug版编译的，不是dbug不会烫残留值
	  2、访问了未初始化的数据；

	六、保存寄存器环境；
	                   调用函数和，被调函数 有些重要值要放入寄存器中处理，在放入前要对其进行保存，不然
					   最后被寄存器修改后。在函数回家前可以按照这个保存值进行环境还原。
	七、debug选项组会将局部变量的初值设定为0xccccccc（这一步会造成有debug正常,relec不正常这种情况）

	八、执行函数体
	九、恢复寄存器环境
	十、释放局部变量空间
	十一、恢复调用方的栈底
	十二、释放参数
	              1、如果是_cdcl约定，弹出栈顶位置存放的值作为返回地址。由调用方释放空间参数
				  2、其他调用约定，弹出栈顶位置存放的值作为返回地址，并由被调放释放参数空间。
	
	*/
    foo(1,2);
	system("pause");
    return 0;
}
```

![image-20211120075943518](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211120075943518.png)



<img src="http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211120090227926.png" alt="image-20211120090227926" style="zoom:33%;" /><img src="http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211120090527502.png" alt="image-20211120090527502" style="zoom:33%;" />

![image-20211120091021728](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211120091021728.png)

##### 2、函数的三大作用

​	   1、复用性
​              2、划分责任
​              3、 规范接口

## 附 录：作业

#### 一、[grammar](javascript:;)

```
1.	写一个函数int prime(int x)，如果x是素数返回值为1，否则返回0。并用主函数验证它。 
2.	写一个函数power(double x, int n)，其返回值为x的n次方，并用此函数计算1.5 3。
3.	求1到10共10个数中取出3个不同的数，共有多少种组合方式？
     算法：使用数学中的组合公式，其中m=10,n=3。

```

#### 二、[daily](javascript:;)

```
笔记：
0、笔记要求图文并茂、勾画出最少三层结构函数a调用b，b调用c，c等等【高版本不是固定地址，可以%p打印出来c函数中的变量地址【最内层某个内存地址，说一说经历了什么】，根据这个地址把推测其它的，来演示】，可以设置若干函数变量【讲过的变量都可以用，指针和结构体除外】。先看自己的三层，再看别人的三层。
作业：
1、输入用户名和密码，验证是否正确，如果正确提示“登录成功”，否则提示“登录失败”，三次失败后，强制退出。
2、账号密码问题考虑反制一下，要求不能使用第三方的保护代码。
3、大数阶乘问题做到秒杀：提示4位4位。
4、绘制五角星。
5、下节课讲递归。11-14homework。有一道题有坑 。不能改题目要求。不改题目原型。1-4题。先预习。
学习方法：少想、多做、少猜。学习方法。语法题不会的速度刷。

```



# Day 6 递归循环差异性

强内聚：一切资源自理；低耦合：减少依赖
		 程序逻辑（业务）和用户界面分离
        在程序逻辑中，业务和算法分离

## 一、递归

![image-20211122183432615](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211122183432615.png)

最内层必须有结果，只有这样后面的递归才能计算。设计递归，最先考虑的是最内侧的结果是什么？有外出逐渐拨，直到找到内层给出答案的模型，返回时带上条件即可。
斐波那契数列：递推的方法定义：*F*(0)=0，*F*(1)=1, *F*(n)=*F*(n - 1)+*F*(n - 2)（*n* ≥ 2，*n* ∈ N*）
递归不适合解线性问题。适合多结果问题。
循环适合解决单一结果的线性问题。
能用循环的就可以用递归，能用递归的也能用循环。

------

挖金币游戏；递归
1、每次面临4种选择，如果递归到内存，还是无解，就返回继续一下个选择。知道找到结果。

![ ](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211122221346946.png)

## 二、循环



## 附录：作业

```
1、分别用递归和循环解决迷宫问题（递归必做，循环是选做题）。
2、动态存储管理系统。（周期：11月23号到11月29号。共计6天）。
笔记：
提交每日笔记
```



# Day 7 数组

一、下标运算；需要一个操作数为整数，另一个操作数位地址。
					数组名是数组第0个元素的地址常量；
					数组内部是不对其

定义：
						type  arr[const] = {var1}
						arr表示数组身份
						var可以是常量、变量、表达式、返回值、只要是一个合理的对应类型的**返回值能引用**



## ==二维数组==

二维数组定义的一般形式是：

```
dataType arrayName[length1][length2];
```

其中，dataType 为数据类型，arrayName 为数组名，length1 为第一维下标的长度，length2 为第二维下标的长度。
我们可以将二维数组看做一个 Excel 表格，有行有列，length1 表示行数，length2 表示列数，要在二维数组中定位某个元素，必须同时指明行和列。例如：
![image-20211202165315717](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211202165315717.png)

```c++
#include <stdio.h>
int main(){
    int i, j;  //二维数组下标
    int sum = 0;  //当前科目的总成绩
    int average;  //总平均分
    int v[3];  //各科平均分
    int a[5][3];  //用来保存每个同学各科成绩的二维数组
    printf("Input score:\n");
    for(i=0; i<3; i++){
        for(j=0; j<5; j++){
            scanf("%d", &a[j][i]);  //输入每个同学的各科成绩
            sum += a[j][i];  //计算当前科目的总成绩
        }
        v[i]=sum/5;  // 当前科目的平均分
        sum=0;
    }
    average = (v[0] + v[1] + v[2]) / 3;
    printf("Math: %d\nC Languag: %d\nEnglish: %d\n", v[0], v[1], v[2]);
    printf("Total: %d\n", average);
    return 0;
}
```

## ==二维数组的初始化（赋值）====

二维数组的初始化可以按行分段赋值，也可按行连续赋值。

例如，对于数组 a[5][3]，按行分段赋值应该写作：

```
int a[5][3]={ {80,75,92}, {61,65,71}, {59,63,70}, {85,87,90}, {76,77,85} };
```

按行连续赋值应该写作：

```
int a[5][3]={80, 75, 92, 61, 65, 71, 59, 63, 70, 85, 87, 90, 76, 77, 85};
```

这两种赋初值的结果是完全相同的。

) 二维数组可以看作是由一维数组嵌套而成的；如果一个数组的每个元素又是一个数组，那么它就是二维数组。当然，前提是各个元素的类型必须相同。根据这样的分析，一个二维数组也可以分解为多个一维数组，C语言允许这种分解。

例如，二维数组`a[3][4]`可分解为三个一维数组，它们的数组名分别为 a[0]、a[1]、a[2]。

这三个一维数组可以直接拿来使用。这三个一维数组都有 4 个元素，比如，一维数组 a[0] 的元素为 a[0][0]、a[0][1]、a[0][2]、a[0][3]。

1、直接赋值
适合数组元素较少的，各元素的值可以不同。

int arr1[2][3] = { {5, 2, 4}, {10, 2, 1} };
int arr1[2][3] = {0}; /* 所有元素都初始化为0 */
int arr1[2][3] = {1}; /* 只有arr1[0][0]为1，其他所有元素都初始化为0 */

------------------------------------------------
2、循环对每个元素赋值
对数组的每个元素进行赋值，各元素的值可以不同。就是效率比较低。

int arr2[2][3];
int i, j;
for (i = 0; i < 2; i++) {
    for (j = 0; j < 3; j++) {
        arr2[i][j] = 2; /* 本例为了简单都赋值成相同值 */
    }
}



![image-20211202172607962](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211202172607962.png)

![image-20211202173300917](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211202173300917.png)

![image-20211204053332784](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211204053332784.png)

![image-20211202173337608](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211202173337608.png)

![ ](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211202174317405.png)

![image-20211202175454610](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211202175454610.png)

## ==结构体数组==

两种定义方式：
                                1、![image-20211204195650176](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211204195650176.png)



​                       2、![image-20211204200231940](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211204200231940.png)

![image-20211204200437296](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211204200437296.png)

## 附录：作业

```
作业：
1、寻找随机入口点
   a、定义一个局部数组 int ary[5] 。
   b、通过Memory窗口观察0x00400000【基址】（5A 4D）。
   c、基址+0x31处（0x0040003C：基址往后数4行减去4个字节的位置）【命名：地址1】。
   d、在0x0040003C【地址1】处取4个字节对应的数值。
   e、定位到对应的地址【命名：地址2】（0x00400000【基址】加上0x0040003C【地址】处取的4个字节的数值），在【地址2】处取出4个字节（验证是否是00 00 45 50）。
   f、再往下找两行半(【地址2】+0x28处)的位置【命名：地址3】,在【地址3】处取4个字节数据，把这4个字节的数据加上【基址】，计算出的结果【命名：地址4】，【地址4】就是程序执行的入口（mainCRTStartup的第一行指令）。
   g、验证：打开栈窗口，点开main函数的上一层（mainCRTStartup），在入口点的左边花括号处打断点（118行处打断点），F5运行，然后alt+8快捷键查看是跟地址4相同，以及对应的数值是否相同。（手工验证完成）
   h、最后代码实现：查询自身入口点位置。

2、优化折半查找算法（如果没有写过的，把常规的冒泡、折半、选择实现一遍）。

3、洗牌算法（基于随机点名系统：先完成排序，再查找）。

4、下标运算的本质：取0x00400042地址处的内容，并用int型输出。【ps：把随机基质关闭或者用vc6.0，】。

5、动态存储管理项目
规定数组
 char g_szBuf[0x5000]

今日作业提示：
	位运算 


笔记：
提交每日笔记

Ps：语法题薄弱的，速度刷，账号密码登录系统用可逆算法加不可逆算法优化。
语法题：
1.	已知一个数组a[5]={1,2,3,4,5}、b[5]={11,4,2,7,9}数组c[5]等于数组a、b对应元素之和。输出数组c中个元素的值。
2.	写一个函数void change(int array[],int n)，可以将数组array中的n个元素逆序存放。即array[0]与a[n-1]互换，array[1]与array[n-2]互换……。
3.	求两个矩阵的乘积c。已知矩阵a、b的值： 
4.	应用数组实现输入年year、月month、日date，计算该日期是这年的第几天。方法：定义二维数组days_of_month[2][12]，令该数组第一行由非闰年的12个月的天数组成，第二行由闰年12个月的天数组成，则根据年判断：闰年时i为1、非闰年时i为0，累计days_of_month[i][0]到days_of_month[i][month-1]的天数，再加上date，得到总天数。
5.	根据例7.10的算法，修改例7.8，要求按照平均成绩从高到低的顺序输出学号和平均分。提示：对平均分aver排序，当aver元素互换时，学号num元素对应互换。
6.	如果选择1，调用例7.9的输入函数input()；选择2，调用void search(long num[],float aver[],int n)，该函数可以根据输入的学号输出该学生的各课成绩和平均分；选择3，调用例7.9的输出函数output()；选择0，显示“谢谢使用”；选择其它则显示“输入错误，请重新输入”。
      该程序只有当输入选择为“0”时结束，否则返回主菜单 
7.	编写一个函数string_change(char str[])，要求实现str中的字符的互换。如”abcde”换成”edcba”。
8.	编写一个函数char_search(char str[],char c)，如果字符串str中包含字符c则返回数值1，否则返回数值0。
9.	编写一个函数string_cut(char string[],char c)，其功能是删除字符串中所有的字符变量c，例如
       char string=“abaca”; char c=’a’;
       则执行string_cut(string,c)后，string的内容变为”bc”。
10.	编写一个函数string_search(char str1[],char str2[])，如果字符串str1中包含字符串2则返回数值1，否则返回数值0

11.	写一个函数int prime(int x)，如果x是素数返回值为1，否则返回0。并用主函数验证它。 
12.	写一个函数power(double x, int n)，其返回值为xn，并用此函数计算1.53。


13.	用递归算法编写求Fibonacci数列第n项值的函数fib(int n)，并用主函数输出它的前20项来验证该函数



14．	定义3个整型变量及指向整型变量的指针变量，利用3个指针变量完成数据的输入、从小到大排序、输出。

15．	已知一个整型数组a[10]，要求定义2个指向整型变量的指针变量max、min，使得它们分别指向数组的最大数和最小数。

16．	编写一个函数int palindrome(char *string)，如果字符串string是回文，返回值为1，否则为0。“回文”指顺读、逆读都一样的字符串，例如”12321”、”abba”。

17．	编写一个函数string_in(char *str1,char *str2)，如果字符串str1中包含字符串str2，则返回数值1，否则返回数值0。

18．	编写一个求子串的函数sub_str(char *s1,char s2[],int m,int n)，其作用是将字符串s1中从第m个字符开始的n个字符放入字符串s2中。

19．	修改函数string_cut(char *string,char c)，要求返回值为字符串的地址。
20．	编写并验证去掉字符串中前导空格的函数char *head_cls(char *str)。
21．	修改例11.9，已知学生库char *name[6] = {“Join”, ”Mary”,”Lily”,”Bob”,”Williams”,”White”};要求根据输入学生姓名查找该学生是第几个。
22．	利用main函数可以读取命令行参数，建立文件like.c。当命令行有2个参数时，例如like football ，输出Do you like football? 当命令行有3个参数时，例如like  football  basketball 时，输出Do you like football or basketball? 当命令行有4个以上参数时，例如like C Vb Foxpro Java 时输出Do you like C,Vb,Foxpro or Java?

```

# Day 8

## ==折半查找==

![image-20211124214122829](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211124214122829.png)

## 附录：作业

多维数组：数组在内存中的排列都是一样的。没差异。
                             本质还是数组中的数组，
									内存结构和一维数组相同，每个元素地址相邻。数据类型一致
									不能按照行列式去理解。
									所有数组的特点：连续（内存地址）且一致（数据类型一致）

作业：
1、用筛选法求100以内的素数。
2、求3到21之间的幻方。（行和列是奇数，偶数的暂时不要求）

笔记：
提交每日笔记

明天讲课内容：
字符、字符串。（函数不讲：例如，puts等，掌握不清晰的需要预习一下）


Ps：折半的应用：利用平方根提升效率，同时考虑存在double类型的数据、做着玩玩。项目每天的日志、和计划别忘记提交。

# Day 9

## 案例：贪吃蛇思路

## ==1、如何描述墙，墙体和蛇==





# Day 10 字符串

## 字符数组

### 1.字符数组的定义与初始化

​       定义字符数组的一般格式为：char  数组名[常量表达式]；
字符数组的初始化有三种不同的方式：
（1）用单个字符常量对字符数组进行初始化。 例如：char s[]={‘G’,’o’,’o’,’d’,’\0’};
（2）用字符的ASCII码值对字符数组进行初始化。 例如：char s[]={71,111,111,100,0};
  （3）直接把一个字符串赋予一个字符数组。 例如： char s[]=“Good”;

### 2.字符数组的输入输出

利用scanf函数和printf函数的%s格式对字符数组整体进行输入输出。例如： char str[20];     scanf(“%s”,str);      printf(“%s”，str);
（2）逐个输入输出字符数组中的每一个字符。如上例可改写为：   for(i=0;i<20;i++) scanf (“%c”,&str[i]);          for(i=0;i<20;i++) printf (“%c”, str[i]);

## 字符串处理函数

strstr 
  定义两指针
  遍历并截取
  比较字符串
  继续向后移



```
作业：
1、strcpy、strlen、strcmp等字符串函数实现（ps：语法薄弱的实现一下）
2、班上同学的名字按ascii排序。
3、提取语法关键字，将来做混淆器用的到。取一段汇编代码，统计操作数、指令、运算值、出现次数以及出现频率。【ps：长期作业不做检查】(例如命令行混淆：cmd /c whoami == cmd ,;;;;;;;;; /c whoami）

下节课内容：
局部静态和全局静态

笔记：
提交每日笔记


Ps：项目每天的日志别忘记提交。
```

# Day 11 静态全局变量



## ==**静态全局变量**==：

它的作用域：所在定义文件（那个里定义那个文件用不能超过这个文件的范围，生命期和原理和全局一模一样

​                                 除了被限制在本文件内其它和全局变量没任何区别，它是面向对								 象的原型。
​		![image-20211130075146309](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211130075146309.png)			

编译和链接器会联合检查 

静态局部变量

```
作业：
1、静态全局、静态局部、初始化成常量和变量的情况，查看名称粉碎、图文并茂、是否初始化修改观察。放在笔记里面。
2、应用局部静态变量实现输入n,输出1+2+... ..+n的结果。
3、定义带参数的宏MAX(a,b)、MIN(a,b)、ABS(a)分别求两个数的最大值、最小值和一个数的绝对值 
4、定义宏名LEAP YEAR (year)和Isupper(a)，判断year是否是闰年以及a是否是大写字母。
5、完善项目

笔记：
提交每日笔记
```

# **Day 12 宏**

## ==**1、符号常量宏**==

> - **表示错误信息，表示文件打开 。。等**
> - ​        **#define PI 3.14f**
> - ​        **#define FILE_OPEN_ERROR   -1**
> - ​        **#define FILE_ACCESS_ERROR -2**

<img src="http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211130140409919.png" alt="image-20211130140409919"  />

![image-20211130233706250](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211130233706250.png)

![image-20211130140543919](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211130140543919.png)

编译选项 -p 在错误检查之前；-P  :编译看后查看结果

## ==**2、带参数宏**==

> - ​       因无法精确计算，来组织工程，避开宏的依赖关系，
> - ​			1、在头文件里不要放任何有处理器行为代码（赋了初值的全局变量，函数等），只放声明   和预处理；  
> - ​			2、在有参宏的内部，每个参数都加括号，表达式也要加括号；两处括号

​			编译器预处理阶段，对宏就是字符串的替换工作。

<img src="http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211130210849034.png" alt="image-20211130210849034"  />

<img src="http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211130211507291.png" alt="image-20211130211507291" style="zoom:150%;" />

## ==**3、语句块宏**==

可以用来表达语句块，看起来更像是函数；  展开由多个语句构成。

 <img src="http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211130211244679.png" alt="image-20211130211244679" style="zoom:80%;" />

输入参数后，自动换行加暂停

![image-20211130222633851](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211130222633851.png)

![ ](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211130224720594.png)

## ==**4、系统内置宏**==

- //__FILE__ 编译器遇到它，会替换成当前源文件的全路径(定义_FILE_源码的全路径）
- //__LINE__             引用_LINE_源码的行数。
- //__cplusplus   当前编译环境是不是c++
- //....等
  系统内置宏不能夸平台

![image-20211130235342500](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211130235342500.png)

## ==**5、预定义宏**==

通常和条件编译在一起搭配；
			条件编译：

![image-20211201073212801](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211201073212801.png)		 
      如果后面非0，就参与预编译，这个分支不是在运行的，是在预编译处理前的宏处理判断
 案例：宏的判断  dubug 执行 release不执行 打印报错

![image-20211201073615754](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211201073615754.png)

​			![image-20211201001208434](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211201001208434.png)

上面这个处理有范围，如果解决整个工程文件呢？用-D选项，加入到它

![image-20211201001016181](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211201001016181.png) 

**–D XX**   这个叫编译预处理宏，这个宏的好处2点：
        1、它在命令行中，在编译脚本中，它可以确保在所有的文件引用前；
		  2、if 换成ifdef （就是成了检查改宏是否有定义，而不像if 关心值）当宏有定义了则参与编译，没定义则不参
               参与编译。
               ifdef(如果有定义)
               ifndef（如果无定义）
               都可以插入#else

![image-20211201001532880](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211201001532880.png)

![image-20211201001744562](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211201001744562.png)

![image-20211201001839947](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211201001839947.png)



—FILE_  等：会在生成的任何版本中包含全路径信息，安全性隐患极大（会产生字符串常量值） 

```c++
#include"MyLib.h"

//0、符号化常量宏
//表示错误信息，表示文件打开 。。等
#define PI 3.14f
#define FILE_OPEN_ERROR   -1
#define FILE_ACCESS_ERROR -2
 
//1、表达式宏
#define GET_AREA(r) (PI+(r)+(r))
//2、语句块宏
#define DEF_MIN(TYPE)\
TYPE TYPE##_MIN(TYPE x, TYPE y)\
{\
	if(x>y)\
	{\
	return y;\		
	}\
	return x;
}
#define CALL_MIN(TYPE,x,y) TYPE##_MIN(x,y)

//模板实例化
DEF_MIN(int);
DEF_MIN(float);
DEF_MIN(char);

#define TEST(x,y) x##y

// 3、兼容性宏
//1、
#define for if(1)for
//2、
#define INT int   

//4、系统内置宏（能获得很多系统内置信息)
//__FILE__ 编译器遇到它，会替换成当前源文件的全路径(定义_FILE_源码的全路径）
//__LINE__             引用_LINE_源码的行数。
//__cplusplus
//....等

//5、预定义宏
int main(int argc)
{
	//模板调用
	int n = CALL_MIN(int,1,2);
	float f =CALL_MIN(float,1.0f,2.0f);
	char c = CALL_MIN(char,'1','2');
	// -----------------------------------------------------
	if(1)//用兼容性宏强行变为块作用域；展开把if(1)换成for；for只算一遍，
	{
		for(int i = 0;i<5;i++)// i是函数作用域，不是块作用域【vc6函数作用域，2019是函数作用域】
		{
			SHOW_MENU("***************************");
		}
	}
	
    /*	
    for(int i = 0;i<5;i++)// i是函数作用域，不是块作用域【vc6函数作用域，2019是函数作用域】
	{
		SHOW_MENU("***************************");
	} 
	万一项目是2个版本 高版本 和低版本都用，这个for循环中的i，咋解决呢、
	*/

	// -----------------------------------------------------
	
	float r = PI;
	printf("%f\r\n",GET_AREA(R+3.0f)*5);

	system("pause");
	return FILE_ACCESS_ERROR;
}
```

## ==**6、源码的组织结构 **==

>
>  		场景：先写好代码，运行报各种错误，查文件，看缺什么库，那里缺那里加：
>
> ifndef (如果未定义) MY_LIB_H（用它给未定义的宏 直接上定义，需要后面直接添加用的宏即可，
> 		                                                        解决了宏定义的依赖关系问题，加了他，代码体的宏，谁没定义谁就
>                                                               上头文件，这种机制就是规避头文件互相包含的问题）	     
> 		  #define MY_lIB_H    这里就定义     就不会出现重复定义，
>
> C文件放代码	（在乎被包含次数，即使做了重复包含也没用，编译器按照工程项目所有的.c文件进
>                                    进行预编译，每个文件include互包含后，预编译语法可以过，这样在文件替换后。会											出现同名函数同名变量，在链接后，都会出现同名的导出错，（编译是每个文件单独
>                                     编译，所以不会出错，链接是全部文件链接，同名出现就报错）            
>          H文件文件
>                                  放声明和类型定义（不产生处理器行为 东西）（h文件不在乎被包含多次的

![image-20211201065946330](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211201065946330.png)



![image-20211201071713328](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211201071713328.png)

凡是IDE环境创建的头文件，都会帮我们做防止重复包含处理

![image-20211201072517930](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211201072517930.png)

![image-20211201072622288](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211201072622288.png)

# Day13 指针



指针的应用场景：要区分对待
        指针：存放别的变量地址，叫指针变量；没针（英文原意是：将内存理解为一条线，指针是上面的一个点。
		  内存结构是学指针的进阶，指针的语法很简单；
		  指针的特点：简单粗暴，破坏性极强；

语法规范：
                           指针任何时候都初始为NULL，不允许让指针的状态未知；（不允许那行代码，任何一个瞬间指令 
                           中它的状态是未知的  ，任何时候  ，任何时间点，我们必须清楚指针的状态；
                            编译器让它存储2个信息：
																						1、存放的地址 是什么；
																						2、解释方式（也叫类型）
                                    	                 		        具备这2点，编译器才让取值；在编译中，有个表来记录指针的这些信息
                                                                       生成代码的时候，从表中取出解释方式，生成对应的代码;																					    譬如内存中的一个地址，是无法正确取值的；
				对了解内存的人指针比较友好；  
			![image-20211201162933156](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211201162933156.png)



![image-20211201165353880](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211201165353880.png)

## ==解释方式==：

比地址更重要；因为地址通过公式可以轻易解决；而最容易出错的总是type类型（解释方式）
        15行这里，*p取内容，也等于说是解释目标内存是什么， 浮点编译器就产生浮点指令；整形就产生整形指令
        整形指针取内容就把目标当成 4字节补码去解释它；对应的汇编指令很会上来
        要是float*都是4字节，一旦取内容，目标就要当成单精度浮点，编译器就要产生浮点指令：
		  指针是什么类型，将来对这个地址的解释就按照什么类型来；
 void* 指针是没有解释方式；仅存地址，不存解释方式；void*不强转，取不了内容；不能做任何运算
         解释内存中的信息需要2个条件：1、地址；2、解释方式

间接访问过程：*p=666  第一次访问它地址（内存地址0019FF2C ），取出 里面存放的值0019ff28，做第二次访问，然后将次地址解释为int,然后写入666的值；
![image-20211203090321394](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211203090321394.png)
![image-20211203090527689](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211203090527689.png)

![image-20211203091232954](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211203091232954.png)

栈会初始化位cc，所有在debug环境下它是有初始值的cc,p的初始值是cc，
![image-20211203091431049](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211203091431049.png)

*p 它去访问0x cccccccc操作系统不允许访问，它是操作系统的地址，三环地址，只有0环程序可以访
          问，而我们现在是三环程序，访问不了，所以c05，c05是报访问权限问题；
         解决办法：直接F5定位到访问权限的代码处，如果因为传递的很深在某个函数内部，立马就应该开
                             栈窗口，找到其根源，
![image-20211203092748729](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211203092748729.png)

----

## ==指针的运算==

$$
\begin{align}
     & type *p=…;\\
     & int n = …;\\
     & 指针加整形得到同类型的指针常量\\
     & p+n=(int)p+n*sizeof(type)\\
     & 指针做下标运算,得到对指针类型的变量的应用\\
     & p[n]=(type*)((int)p+n*sizeof(type))\\
     & 同类指针相减，结果位正常常量；\\
     & type *p1=....\\
     & type *p2=....\\
     & p1-p2 =((int)p1-(int)p2)/sizeof(tpye)\\
\end{align}
$$

**![image-20211203094934253](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211203094934253.png)**

## ==**附件**==：作业



> 1.	已知一个数组a[5]={1,2,3,4,5}、b[5]={11,4,2,7,9}数组c[5]等于数组a、b对应元素之和。输出数组c中个元素的值。
> 2.	写一个函数void change(int array[],int n)，可以将数组array中的n个元素逆序存放。即array[0]与a[n-1]互换，array[1]与array[n-2]互换……。
> 3.	求两个矩阵的乘积c。已知矩阵a、b的值： 
> 4.	应用数组实现输入年year、月month、日date，计算该日期是这年的第几天。方法：定义二维数组days_of_month[2][12]，令该数组第一行由非闰年的12个月的天数组成，第二行由闰年12个月的天数组成，则根据年判断：闰年时i为1、非闰年时i为0，累计days_of_month[i][0]到days_of_month[i][month-1]的天数，再加上date，得到总天数。
> 5.	根据例7.10的算法，修改例7.8，要求按照平均成绩从高到低的顺序输出学号和平均分。提示：对平均分aver排序，当aver元素互换时，学号num元素对应互换。
> 6.	如果选择1，调用例7.9的输入函数input()；选择2，调用void search(long num[],float aver[],int n)，该函数可以根据输入的学号输出该学生的各课成绩和平均分；选择3，调用例7.9的输出函数output()；选择0，显示“谢谢使用”；选择其它则显示“输入错误，请重新输入”。
>       该程序只有当输入选择为“0”时结束，否则返回主菜单 
> 7.	编写一个函数string_change(char str[])，要求实现str中的字符的互换。如”abcde”换成”edcba”。
> 8.	编写一个函数char_search(char str[],char c)，如果字符串str中包含字符c则返回数值1，否则返回数值0。
> 9.	编写一个函数string_cut(char string[],char c)，其功能是删除字符串中所有的字符变量c，例如
>        char string=“abaca”; char c=’a’;
>        则执行string_cut(string,c)后，string的内容变为”bc”。
> 10.	编写一个函数string_search(char str1[],char str2[])，如果字符串str1中包含字符串2则返回数值1，否则返回数值0
>
> 11.	写一个函数int prime(int x)，如果x是素数返回值为1，否则返回0。并用主函数验证它。 
> 12.	写一个函数power(double x, int n)，其返回值为xn，并用此函数计算1.53。
>
>
> 13.	用递归算法编写求Fibonacci数列第n项值的函数fib(int n)，并用主函数输出它的前20项来验证该函数
>
> 
>
> 14．	定义3个整型变量及指向整型变量的指针变量，利用3个指针变量完成数据的输入、从小到大排序、输出。
>
> 15．	已知一个整型数组a[10]，要求定义2个指向整型变量的指针变量max、min，使得它们分别指向数组的最大数和最小数。
>
> 16．	编写一个函数int palindrome(char *string)，如果字符串string是回文，返回值为1，否则为0。“回文”指顺读、逆读都一样的字符串，例如”12321”、”abba”。
>
> 17．	编写一个函数string_in(char *str1,char *str2)，如果字符串str1中包含字符串str2，则返回数值1，否则返回数值0。
>
> 18．	编写一个求子串的函数sub_str(char *s1,char s2[],int m,int n)，其作用是将字符串s1中从第m个字符开始的n个字符放入字符串s2中。
>
> 19．	修改函数string_cut(char *string,char c)，要求返回值为字符串的地址。
> 20．	编写并验证去掉字符串中前导空格的函数char *head_cls(char *str)。
> 21．	修改例11.9，已知学生库char *name[6] = {“Join”, ”Mary”,”Lily”,”Bob”,”Williams”,”White”};要求根据输入学生姓名查找该学生是第几个。
> 22．	利用main函数可以读取命令行参数，建立文件like.c。当命令行有2个参数时，例如like football ，输出Do you like football? 当命令行有3个参数时，例如like  football  basketball 时，输出Do you like football or basketball? 当命令行有4个以上参数时，例如like C Vb Foxpro Java 时输出Do you like C,Vb,Foxpro or Java?

# Day14 函数指针

## ==*p++==

## ==函数指针==

概念：保存函数的首地址，由函数指针描述的约定和参数序列产生调用模板，运行期间确定执行目标

同类函数：调用约定一致，返回值一致，参数序列一致（参数类型、个数、和名称无关）
		  定义函数指针机制制作一个函数模板，定义函数指针，本质就是把同类函数的三个要求描述说明

定义：已整形为例：函数的返回类型int(调用约定*函数指针名 )(int,int)   
                                            参数不用名称，只表类型即可 

​               <img src="http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211203074237303.png" alt="image-20211203074237303" style="zoom:80%;" />

<img src="http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211203074639193.png" alt="image-20211203074639193" style="zoom: 80%;" />



编译选项-Zi特性：带调试信息 ，只存在与dbug版特性：用来区别标准库和用户自定义函数从0040100 
                                         开始,下面有几个自定义函数就放几个jmp（E9 1C 00 00 00); 编译器会给我们自动生
                                          成一个跳表，用来统一管理，JMP（goto)，目的是便于我们调试程序，所以程序 
                                         最开始 ，   第一条指令是jmp地址，下来才是函数的地址；  
                                                                        
![image-20211203075733842](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211203075733842.png)

低版本编译器是固定靶，401000是代码段首地址，
       高版本的编译器是无法通过jmp来识别自定义函数不行，因为它的多库函数也是带jmp

代码段、数据段，类似一个容器，操作系统给做了个按照属性的分类，不是业务性分类，直接调用时

######          固定地址，本地程序的算法是写死的，用动态链接库实现，间接调用一个地址（函数指针）

----

![image-20211203083352869](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211203083352869.png) 

 语法
		  原理
		  设计
					强内聚低耦合
                逻辑和界面（Ui)分离
                业务和算法分离

## ==函数指针的案例应用==

## ==附件：作业==

>
> 1.实现一个二维数组的遍历【ps：选做】
> 2.实现一个3*3矩阵的置换【ps：选做】
> 3.通过函数指针数组把高效的实现，
> 输入0，输出hello
> 输入1，输出world
> 输入2，输出c++
> 输入3，输出asm
> 输入其它输出：出错
> 4.请编一函数void fun(int tt[M][N],int pp[N])，tt指向一个M行N列的二维数组，求出二维数组每列中最小元素，并依次放入pp所指一维数组中，二维数组中的数已在主函数中赋予。【ps：选做】
> 5.程序定义了N*N的二维数组，并在主函数中赋值。请编写函数fun，函数的功能是：给数组周边元素置0值【ps：选做】
> 6.将
> int funtest()
> {
> 	printf("Hello world\r\n");
> 	return 0;
> }
> 在本机的机器码用十六进制输出来
>
> 7.将这些十六进制数据作为无参函数运行一下，
> 并输出其十进制返回值B8 23 01 00 00 C3
>
>
> 8、输出子串及子串后面的内容
> char *strstr("Hello",'e');    "ello"  
> char *strstr("Hello",'ll');    "llo"   
> 笔记：
> 提交每日笔记
>
> 明天讲课内容：
> 指针数组
> 数值指针

# Day 15  指针数组&数组指针&命令行参数

## ==指针数组==

元素是指针，指针形数组，指针是定长的，指向的内容是变长的；
		  内存结构：
                            数组是定长，指针是定长的，指向的数据是变长的;空间换时间每个字符串多了4个自己的存储空间
                            存储指针地址；

​        变成数组：查找不方面，节约空间
​                定长数组：查找方便，不节约空间

优点：1、每个字符串多了四字节的存储空间，优势是我们访问第N个传的时候很快；我们利用数组
                          优势，可以快速访问到n项的值；  
                    2、 当做变长数组排序的时候;数据不懂，数组里的指针做排序即可，中间额外的增加了指针数组
                            常被叫做索引，它是用线性存储；
         缺点：数量很多的时候，插入和删除开销很大；
         应用场景：就是做索引用  
			![image-20211203181709724](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211203181709724.png)

## ==数组指针==


​        <span style='color:red'> </span>
​        <span style="font-size:2rem; background:yellow;">**1、数组名是数组第0个**
**元素的指针常量**</span>

<span style="font-size:2rem; background:yellow;">**2、取下标运算得到其元素的引用**</span>

<span style="font-size:2rem; background:yellow;">**3、某类型指针加整型得到同类指针常量**</span>

<span style="font-size:2rem; background:yellow;">**4、对某类型指针作*运算，得到对某类型变量的引用**</span>

----

<span style="font-size:2rem; background:yellow;">**前++得到变量指针；后++得到常量指针；**</span>

<span style="font-size:2rem; background:yellow;">**前++得到整形变量；后++得到正常常量；**</span>

```
*p++、(*p)++、*++p、++*p 的区别
int a[5]={1,2,3,4,5};
int *p = a;

*p++ 先取指针p指向的值（数组第一个元素1），再将指针p自增1；

        cout << *p++; //  结果为 1

        cout <<(*p++);  // 1

(*p)++ 先去指针p指向的值（数组第一个元素1），再将该值自增1（数组第一个元素变为2
        cout << (*p)++; //  1
        cout <<((*p)++)  //2
*++p   先将指针p自增1（此时指向数组第二个元素），* 操作再取出该值

        cout << *++p; //  2
        cout <<(*++p)  //2

++*p  先取指针p指向的值（数组第一个元素1），再将该值自增1（数组第一个元素变为2）
      cout <<++*p; //   2    
        cout <<(++*p)  //2

注意，上面的每条cout输出，要单独输出才能得到后面的结果。
```

![image-20211203220305228](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211203220305228.png)

p是整形指针，ary二维数组首地址（第0个元素是int[3]类型首地址常量，明显不一样，所以报错）

![image-20211204052918622](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211204052918622.png)



![image-20211203221211533](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211203221211533.png)

![image-20211204055913088](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211204055913088.png)



按照老师的参数就报错；![image-20211204061055894](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211204061055894.png)

```
*p   是指针变量p指向的变量a的存储内容，*p = 5;

 p   是指针变量的存储内容，因为p指向a，所以p的存储内容（存储空间的值）就是系统为变量a分配的存储地址；

&p  是对指针变量p进行取地址的操作。
*p和**p的区别
int *p ：一级指针，表示p所指向的地址里面存放的是一个int类型的值
int **p ：二级指针，表示p所指向的地址里面存放的是一个指向int类型的指针（即p指向的地址里面存放的是一个指向int的一级指针）
例如：
int i=10; //定义了一个整型变量
int *p=&i; //定义了一个指针指向这个变量
int **p1=&p; //定义了一个二级指针指向p指针
```

内存结构图：

![image-20211204064225267](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211204064225267.png)

![image-20211204070508411](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211204070508411.png)

![image-20211204092304724](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211204092304724.png)
$$
P是int[3]的指针，p[1]得到int[3]\\
int[3]是数组，数组名是Int*常量\\
对int*+1还是int*常量，对int*求[1];得到int;\\
$$
![image-20211204114508727](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211204114508727.png)

对数组名取地址，得到数组的地址。就是int[3]的指针；+1 = +int[3]  sizof(int[3])*1  Int[3]=c   

## ==二级指针==

![image-20211205235751530](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211205235751530.png)

![image-20211205140614893](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211205140614893.png)

![image-20211205140801456](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211205140801456.png)

应用场景：
         

```c++
#include <stdlib.h>
int main()
{
	int ary[2][3] =
	{
		{10,20.30},//ary[0]
		{40,50,60},//ary[1]
	};
	//int *p = ary;//类型不一致，二维数组的第0个元素是Int[3]类型的指针常量；
	
	int (*p)[3]=ary;

// 	int a[3]={1,2,3};
// 	int *p = a;
// 	int *p2=&a;
	printf("%p\r\n",p);//打印变量p的值；

	printf("%p\r\n",*p);//对指向整形取内容得到整形，对指向数组的指针取内容得到数组（数组的引用名是第0个元素的指针常量）引用相当于引用它的首地址

	printf("%p\r\n",**p);//两次取内容，第一次取内容，指向数组的指针取内容得到数组，数组是第0个元素的指针常量，对此再取内容得到整形

	printf("%p\r\n",sizeof(p));//对指针求大小 类型是指针
	printf("%p\r\n",sizeof(*p));//*p是取值是数组，数组的大小是12字节；等于对数组求sieof=12类型是数组
	printf("%p\r\n",sizeof(**p));//4；类型是整形
	printf("%p\r\n",p+1);//int[3]类型的数组的指针，+1 等于sizeof(int[])=12个字节（数组的大小）指针+常量得到同类型常量
	printf("%p\r\n",*p+1);//1、*P得到int[3]，int[3]是数组，数组第0个元素个元素的指针常量；所以得到Int型指针常量；2、int型指针常量+1(sizof(int))=0012FF34     类型还是int型指针常量
	printf("%p\r\n",**p+1);//0000000B
	printf("%p\r\n",p[1]+1);//p是指向数组的指针，p[1]加一个数组的长度（0地址），同时还取了内容；取到内容得到数组；数组又是第0个元素的指针；那就是正在指针；整形指针+1还是整形指针；得到int*类型
	printf("%p\r\n",*((p+1)[1]));//p+1还是指向int[3]的指针，针对Int[3]做下标运算
	printf("%p\r\n",(*(p+1)) [1]);
	printf("%p\r\n",*p[1]+1);//[]优先级高，先取下标运算，得到一维数组，一维数组是第0个元素的整形指针常量，接着对整形指针常量取内容，得到整形，再加1；
	printf("%p\r\n",(p[1]+1)[1]);


	system("pause");
	return 0;
}
```



## ==命令行==

命令行用字符型指针数组做管理
![image-20211205152210005](http://r2peyhc0v.hn-bkt.clouddn.com/img/image-20211205152210005.png)

> 附件：作业
> 
>
> ## 
>
> 作业：
> 1.实现memcpy函数
> 2.将自己的参数倒序输出
> 3.利用指向字符串数组的指针，将数组中的字符串全部连接起来，并输出(总长度不超过100个字符)
> 4.将自己的参数传递调用另一个程序(程序参数不超过500字符)【ddos看雪】
> 5.将传入的参数和环境变量全部输出到文件1.txt
> 6.本周完成加密体系，发群里，别人看源码看不出来，算过关。只发Creakme源码
> 笔记：
> 提交每日笔记、
> a.上课函数指针例子，每个过程写出来
>
>  printf("%p\r\n", p);
>   printf("%p\r\n", *p);
>   printf("%p\r\n", **p);
>   printf("%p\r\n", sizeof(p));
>   printf("%p\r\n", sizeof(*p));
>   printf("%p\r\n", sizeof(**p));
>   printf("%p\r\n", p + 1);
>   printf("%p\r\n", *p + 1);
>   printf("%p\r\n", **p + 1);
>   printf("%p\r\n", p[1] + 1);
>   printf("%p\r\n", *((p + 1)[1]));
>   printf("%p\r\n", (*(p + 1))[1]);
>   printf("%p\r\n", *p[1] + 1);
>   printf("%p\r\n", (p[1] + 1)[1]);
>
>   /*
>     p是int[3]的指针，p[1]得到int[3], 0019FF18 + sizeof(int[3]) = 0019FF24
>     int[3]是数组，数组名是int*常量
>     int* + 1,0019FF24 + sizeof(int) = 0019FF28, 还是int*常量, 
>     对int*0019FF28求[1]，得到0019FF2c处的int
>   */
>
> 下节课讲课内容：
> 结构体
>
> ps：
> 100个变长串的存储？，顺序存储的，搞个排序。[暂时不要求]
>
> 语法题【选做】：
> 1.利用int**,遍历二维int数组
> 2.利用char** ，遍历二维int型数组

# 算法
